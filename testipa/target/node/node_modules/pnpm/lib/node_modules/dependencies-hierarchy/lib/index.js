"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lockfile_file_1 = require("@pnpm/lockfile-file");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const modules_yaml_1 = require("@pnpm/modules-yaml");
const normalize_registries_1 = __importDefault(require("@pnpm/normalize-registries"));
const pkgid_to_filename_1 = __importDefault(require("@pnpm/pkgid-to-filename"));
const read_modules_dir_1 = __importDefault(require("@pnpm/read-modules-dir"));
const read_package_json_1 = require("@pnpm/read-package-json");
const types_1 = require("@pnpm/types");
const dependency_path_1 = require("dependency-path");
const path = require("path");
const normalizePath = require("normalize-path");
const realpathMissing = require("realpath-missing");
const resolveLinkTarget = require("resolve-link-target");
async function dependenciesHierarchy(projectPaths, maybeOpts) {
    var _a, _b, _c;
    if (!maybeOpts || !maybeOpts.lockfileDir) {
        throw new TypeError('opts.lockfileDir is required');
    }
    const modulesDir = await realpathMissing(path.join(maybeOpts.lockfileDir, 'node_modules'));
    const modules = await modules_yaml_1.read(modulesDir);
    const registries = normalize_registries_1.default({
        ...maybeOpts === null || maybeOpts === void 0 ? void 0 : maybeOpts.registries,
        ...modules === null || modules === void 0 ? void 0 : modules.registries,
    });
    const currentLockfile = (_a = ((modules === null || modules === void 0 ? void 0 : modules.virtualStoreDir) && await lockfile_file_1.readCurrentLockfile(modules.virtualStoreDir, { ignoreIncompatible: false }))) !== null && _a !== void 0 ? _a : null;
    const result = {};
    if (!currentLockfile) {
        for (const projectPath of projectPaths) {
            result[projectPath] = {};
        }
        return result;
    }
    const opts = {
        depth: maybeOpts.depth || 0,
        include: (_b = maybeOpts.include) !== null && _b !== void 0 ? _b : {
            dependencies: true,
            devDependencies: true,
            optionalDependencies: true,
        },
        lockfileDir: maybeOpts.lockfileDir,
        registries,
        search: maybeOpts.search,
        skipped: new Set((_c = modules === null || modules === void 0 ? void 0 : modules.skipped) !== null && _c !== void 0 ? _c : []),
    };
    (await Promise.all(projectPaths.map(async (projectPath) => {
        return [
            projectPath,
            await dependenciesHierarchyForPackage(projectPath, currentLockfile, opts),
        ];
    }))).forEach(([projectPath, dependenciesHierarchy]) => {
        result[projectPath] = dependenciesHierarchy;
    });
    return result;
}
exports.default = dependenciesHierarchy;
async function dependenciesHierarchyForPackage(projectPath, currentLockfile, opts) {
    var _a, _b, _c, _d, _e;
    const importerId = lockfile_file_1.getLockfileImporterId(opts.lockfileDir, projectPath);
    if (!currentLockfile.importers[importerId])
        return {};
    const modulesDir = path.join(projectPath, 'node_modules');
    const savedDeps = getAllDirectDependencies(currentLockfile.importers[importerId]);
    const allDirectDeps = (_a = await read_modules_dir_1.default(modulesDir)) !== null && _a !== void 0 ? _a : [];
    const unsavedDeps = allDirectDeps.filter((directDep) => !savedDeps[directDep]);
    const wantedLockfile = (_b = await lockfile_file_1.readWantedLockfile(opts.lockfileDir, { ignoreIncompatible: false })) !== null && _b !== void 0 ? _b : { packages: {} };
    const getChildrenTree = getTree.bind(null, {
        currentDepth: 1,
        currentPackages: (_c = currentLockfile.packages) !== null && _c !== void 0 ? _c : {},
        includeOptionalDependencies: opts.include.optionalDependencies,
        lockfileDir: opts.lockfileDir,
        maxDepth: opts.depth,
        modulesDir,
        registries: opts.registries,
        search: opts.search,
        skipped: opts.skipped,
        wantedPackages: (_d = wantedLockfile.packages) !== null && _d !== void 0 ? _d : {},
    });
    const result = {};
    for (const dependenciesField of types_1.DEPENDENCIES_FIELDS.sort().filter(dependenciedField => opts.include[dependenciedField])) {
        const topDeps = (_e = currentLockfile.importers[importerId][dependenciesField]) !== null && _e !== void 0 ? _e : {};
        result[dependenciesField] = [];
        Object.keys(topDeps).forEach((alias) => {
            var _a, _b, _c;
            const { packageInfo, packageAbsolutePath } = getPkgInfo({
                alias,
                currentPackages: (_a = currentLockfile.packages) !== null && _a !== void 0 ? _a : {},
                lockfileDir: opts.lockfileDir,
                modulesDir,
                ref: topDeps[alias],
                registries: opts.registries,
                skipped: opts.skipped,
                wantedPackages: (_b = wantedLockfile.packages) !== null && _b !== void 0 ? _b : {},
            });
            let newEntry = null;
            const matchedSearched = (_c = opts.search) === null || _c === void 0 ? void 0 : _c.call(opts, packageInfo);
            if (packageAbsolutePath === null) {
                if (opts.search && !matchedSearched)
                    return;
                newEntry = packageInfo;
            }
            else {
                const relativeId = dependency_path_1.refToRelative(topDeps[alias], alias);
                if (relativeId) {
                    const dependencies = getChildrenTree([relativeId], relativeId);
                    if (dependencies.length) {
                        newEntry = {
                            ...packageInfo,
                            dependencies,
                        };
                    }
                    else if (!opts.search || matchedSearched) {
                        newEntry = packageInfo;
                    }
                }
            }
            if (newEntry) {
                if (matchedSearched) {
                    newEntry.searched = true;
                }
                result[dependenciesField].push(newEntry);
            }
        });
    }
    await Promise.all(unsavedDeps.map(async (unsavedDep) => {
        var _a, _b, _c;
        let pkgPath = path.join(modulesDir, unsavedDep);
        let version;
        try {
            pkgPath = await resolveLinkTarget(pkgPath);
            version = `link:${normalizePath(path.relative(projectPath, pkgPath))}`;
        }
        catch (err) {
            // if error happened. The package is not a link
            const pkg = await read_package_json_1.safeReadPackageFromDir(pkgPath);
            version = (_a = pkg === null || pkg === void 0 ? void 0 : pkg.version) !== null && _a !== void 0 ? _a : 'undefined';
        }
        const pkg = {
            alias: unsavedDep,
            isMissing: false,
            isPeer: false,
            isSkipped: false,
            name: unsavedDep,
            path: pkgPath,
            version,
        };
        const matchedSearched = (_b = opts.search) === null || _b === void 0 ? void 0 : _b.call(opts, pkg);
        if (opts.search && !matchedSearched)
            return;
        const newEntry = pkg;
        if (matchedSearched) {
            newEntry.searched = true;
        }
        result.unsavedDependencies = (_c = result.unsavedDependencies) !== null && _c !== void 0 ? _c : [];
        result.unsavedDependencies.push(newEntry);
    }));
    return result;
}
function getAllDirectDependencies(projectSnapshot) {
    return {
        ...projectSnapshot.dependencies,
        ...projectSnapshot.devDependencies,
        ...projectSnapshot.optionalDependencies,
    };
}
function getTree(opts, keypath, parentId) {
    const dependenciesCache = new Map();
    return getTreeHelper(dependenciesCache, opts, keypath, parentId).dependencies;
}
function getTreeHelper(dependenciesCache, opts, keypath, parentId) {
    var _a;
    const result = { dependencies: [] };
    if (opts.currentDepth > opts.maxDepth || !opts.currentPackages || !opts.currentPackages[parentId])
        return result;
    const deps = !opts.includeOptionalDependencies
        ? opts.currentPackages[parentId].dependencies
        : {
            ...opts.currentPackages[parentId].dependencies,
            ...opts.currentPackages[parentId].optionalDependencies,
        };
    if (!deps)
        return result;
    const getChildrenTree = getTreeHelper.bind(null, dependenciesCache, {
        ...opts,
        currentDepth: opts.currentDepth + 1,
    });
    const peers = new Set(Object.keys((_a = opts.currentPackages[parentId].peerDependencies) !== null && _a !== void 0 ? _a : {}));
    Object.keys(deps).forEach((alias) => {
        var _a;
        const { packageInfo, packageAbsolutePath } = getPkgInfo({
            alias,
            currentPackages: opts.currentPackages,
            lockfileDir: opts.lockfileDir,
            modulesDir: opts.modulesDir,
            peers,
            ref: deps[alias],
            registries: opts.registries,
            skipped: opts.skipped,
            wantedPackages: opts.wantedPackages,
        });
        let circular;
        const matchedSearched = (_a = opts.search) === null || _a === void 0 ? void 0 : _a.call(opts, packageInfo);
        let newEntry = null;
        if (packageAbsolutePath === null) {
            circular = false;
            newEntry = packageInfo;
        }
        else {
            let dependencies;
            const relativeId = dependency_path_1.refToRelative(deps[alias], alias); // we know for sure that relative is not null if pkgPath is not null
            circular = keypath.includes(relativeId);
            if (circular) {
                dependencies = [];
            }
            else {
                dependencies = dependenciesCache.get(packageAbsolutePath);
                if (!dependencies) {
                    const children = getChildrenTree(keypath.concat([relativeId]), relativeId);
                    dependencies = children.dependencies;
                    if (children.circular) {
                        result.circular = true;
                    }
                    else {
                        dependenciesCache.set(packageAbsolutePath, dependencies);
                    }
                }
            }
            if (dependencies.length) {
                newEntry = {
                    ...packageInfo,
                    dependencies,
                };
            }
            else if (!opts.search || matchedSearched) {
                newEntry = packageInfo;
            }
        }
        if (newEntry) {
            if (circular) {
                newEntry.circular = true;
                result.circular = true;
            }
            if (matchedSearched) {
                newEntry.searched = true;
            }
            result.dependencies.push(newEntry);
        }
    });
    return result;
}
function getPkgInfo(opts) {
    var _a;
    let name;
    let version;
    let resolved;
    let dev;
    let optional;
    let isSkipped = false;
    let isMissing = false;
    const depPath = dependency_path_1.refToRelative(opts.ref, opts.alias);
    if (depPath) {
        let pkgSnapshot;
        if (opts.currentPackages[depPath]) {
            pkgSnapshot = opts.currentPackages[depPath];
            const parsed = lockfile_utils_1.nameVerFromPkgSnapshot(depPath, pkgSnapshot);
            name = parsed.name;
            version = parsed.version;
        }
        else {
            pkgSnapshot = opts.wantedPackages[depPath];
            if (pkgSnapshot) {
                const parsed = lockfile_utils_1.nameVerFromPkgSnapshot(depPath, pkgSnapshot);
                name = parsed.name;
                version = parsed.version;
            }
            else {
                name = opts.alias;
                version = opts.ref;
            }
            isMissing = true;
            isSkipped = opts.skipped.has(depPath);
        }
        resolved = lockfile_utils_1.pkgSnapshotToResolution(depPath, pkgSnapshot, opts.registries)['tarball'];
        dev = pkgSnapshot.dev;
        optional = pkgSnapshot.optional;
    }
    else {
        name = opts.alias;
        version = opts.ref;
    }
    const packageAbsolutePath = dependency_path_1.refToRelative(opts.ref, opts.alias);
    const packageInfo = {
        alias: opts.alias,
        isMissing,
        isPeer: Boolean((_a = opts.peers) === null || _a === void 0 ? void 0 : _a.has(opts.alias)),
        isSkipped,
        name,
        path: depPath ? path.join(opts.modulesDir, '.pnpm', pkgid_to_filename_1.default(depPath, opts.lockfileDir)) : path.join(opts.modulesDir, '..', opts.ref.substr(5)),
        version,
    };
    if (resolved) {
        packageInfo['resolved'] = resolved;
    }
    if (optional === true) {
        packageInfo['optional'] = true;
    }
    if (typeof dev === 'boolean') {
        packageInfo['dev'] = dev;
    }
    return {
        packageAbsolutePath,
        packageInfo,
    };
}
//# sourceMappingURL=index.js.map