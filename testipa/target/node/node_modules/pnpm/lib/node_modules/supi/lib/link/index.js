"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkToGlobal = exports.linkFromGlobal = void 0;
const core_loggers_1 = require("@pnpm/core-loggers");
const error_1 = __importDefault(require("@pnpm/error"));
const get_context_1 = require("@pnpm/get-context");
const link_bins_1 = require("@pnpm/link-bins");
const lockfile_file_1 = require("@pnpm/lockfile-file");
const logger_1 = __importStar(require("@pnpm/logger"));
const manifest_utils_1 = require("@pnpm/manifest-utils");
const modules_cleaner_1 = require("@pnpm/modules-cleaner");
const prune_lockfile_1 = require("@pnpm/prune-lockfile");
const read_project_manifest_1 = __importDefault(require("@pnpm/read-project-manifest"));
const symlink_dependency_1 = require("@pnpm/symlink-dependency");
const types_1 = require("@pnpm/types");
const options_1 = require("./options");
const path = require("path");
const normalize = require("normalize-path");
const pathAbsolute = require("path-absolute");
const R = require("ramda");
async function link(linkFromPkgs, destModules, maybeOpts) {
    var _a, _b, _c, _d, _e;
    const reporter = maybeOpts === null || maybeOpts === void 0 ? void 0 : maybeOpts.reporter;
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.on('data', reporter);
    }
    const opts = await options_1.extendOptions(maybeOpts);
    const ctx = await get_context_1.getContextForSingleImporter(opts.manifest, {
        ...opts,
        extraBinPaths: [],
    });
    const importerId = lockfile_file_1.getLockfileImporterId(ctx.lockfileDir, opts.dir);
    const currentLockfile = R.clone(ctx.currentLockfile);
    const linkedPkgs = [];
    const specsToUpsert = [];
    for (const linkFrom of linkFromPkgs) {
        let linkFromPath;
        let linkFromAlias;
        if (typeof linkFrom === 'string') {
            linkFromPath = linkFrom;
        }
        else {
            linkFromPath = linkFrom.path;
            linkFromAlias = linkFrom.alias;
        }
        const { manifest } = await read_project_manifest_1.default(linkFromPath);
        if (typeof linkFrom === 'string' && manifest.name === undefined) {
            throw new error_1.default('INVALID_PACKAGE_NAME', `Package in ${linkFromPath} must have a name field to be linked`);
        }
        specsToUpsert.push({
            alias: manifest.name,
            pref: manifest_utils_1.getPref(manifest.name, manifest.name, manifest.version, {
                pinnedVersion: opts.pinnedVersion,
            }),
            saveType: ((_a = opts.targetDependenciesField) !== null && _a !== void 0 ? _a : (ctx.manifest && manifest_utils_1.guessDependencyType(manifest.name, ctx.manifest))),
        });
        const packagePath = normalize(path.relative(opts.dir, linkFromPath));
        const addLinkOpts = {
            linkedPkgName: linkFromAlias !== null && linkFromAlias !== void 0 ? linkFromAlias : manifest.name,
            manifest: ctx.manifest,
            packagePath,
        };
        addLinkToLockfile(ctx.currentLockfile.importers[importerId], addLinkOpts);
        addLinkToLockfile(ctx.wantedLockfile.importers[importerId], addLinkOpts);
        linkedPkgs.push({
            alias: linkFromAlias !== null && linkFromAlias !== void 0 ? linkFromAlias : manifest.name,
            manifest,
            path: linkFromPath,
        });
    }
    const updatedCurrentLockfile = prune_lockfile_1.pruneSharedLockfile(ctx.currentLockfile);
    const warn = (message) => logger_1.default.warn({ message, prefix: opts.dir });
    const updatedWantedLockfile = prune_lockfile_1.pruneSharedLockfile(ctx.wantedLockfile, { warn });
    await modules_cleaner_1.prune([
        {
            binsDir: opts.binsDir,
            id: importerId,
            modulesDir: ctx.modulesDir,
            rootDir: opts.dir,
        },
    ], {
        currentLockfile,
        hoistedDependencies: ctx.hoistedDependencies,
        hoistedModulesDir: (_b = (opts.hoistPattern && ctx.hoistedModulesDir)) !== null && _b !== void 0 ? _b : undefined,
        include: ctx.include,
        lockfileDir: opts.lockfileDir,
        publicHoistedModulesDir: (_c = (opts.publicHoistPattern && ctx.rootModulesDir)) !== null && _c !== void 0 ? _c : undefined,
        registries: ctx.registries,
        skipped: ctx.skipped,
        storeController: opts.storeController,
        virtualStoreDir: ctx.virtualStoreDir,
        wantedLockfile: updatedCurrentLockfile,
    });
    // Linking should happen after removing orphans
    // Otherwise would've been removed
    for (const { alias, manifest, path } of linkedPkgs) {
        // TODO: cover with test that linking reports with correct dependency types
        const stu = specsToUpsert.find((s) => s.alias === manifest.name);
        await symlink_dependency_1.symlinkDirectRootDependency(path, destModules, alias, {
            fromDependenciesField: (_d = stu === null || stu === void 0 ? void 0 : stu.saveType) !== null && _d !== void 0 ? _d : opts.targetDependenciesField,
            linkedPackage: manifest,
            prefix: opts.dir,
        });
    }
    const linkToBin = (_e = maybeOpts === null || maybeOpts === void 0 ? void 0 : maybeOpts.linkToBin) !== null && _e !== void 0 ? _e : path.join(destModules, '.bin');
    await link_bins_1.linkBinsOfPackages(linkedPkgs.map((p) => ({ manifest: p.manifest, location: p.path })), linkToBin, {
        warn: (message) => logger_1.default.info({ message, prefix: opts.dir }),
    });
    let newPkg;
    if (opts.targetDependenciesField) {
        newPkg = await manifest_utils_1.updateProjectManifestObject(opts.dir, opts.manifest, specsToUpsert);
        for (const { alias } of specsToUpsert) {
            updatedWantedLockfile.importers[importerId].specifiers[alias] = manifest_utils_1.getSpecFromPackageManifest(newPkg, alias);
        }
    }
    else {
        newPkg = opts.manifest;
    }
    const lockfileOpts = { forceSharedFormat: opts.forceSharedLockfile };
    if (opts.useLockfile) {
        await lockfile_file_1.writeLockfiles({
            currentLockfile: updatedCurrentLockfile,
            currentLockfileDir: ctx.virtualStoreDir,
            wantedLockfile: updatedWantedLockfile,
            wantedLockfileDir: ctx.lockfileDir,
            ...lockfileOpts,
        });
    }
    else {
        await lockfile_file_1.writeCurrentLockfile(ctx.virtualStoreDir, updatedCurrentLockfile, lockfileOpts);
    }
    core_loggers_1.summaryLogger.debug({ prefix: opts.dir });
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.removeListener('data', reporter);
    }
    return newPkg;
}
exports.default = link;
function addLinkToLockfile(projectSnapshot, opts) {
    var _a, _b, _c;
    const id = `link:${opts.packagePath}`;
    let addedTo;
    for (const depType of types_1.DEPENDENCIES_FIELDS) {
        if (!addedTo && ((_b = (_a = opts.manifest) === null || _a === void 0 ? void 0 : _a[depType]) === null || _b === void 0 ? void 0 : _b[opts.linkedPkgName])) {
            addedTo = depType;
            projectSnapshot[depType] = (_c = projectSnapshot[depType]) !== null && _c !== void 0 ? _c : {};
            projectSnapshot[depType][opts.linkedPkgName] = id;
        }
        else if (projectSnapshot[depType]) {
            delete projectSnapshot[depType][opts.linkedPkgName];
        }
    }
    // package.json might not be available when linking to global
    if (!opts.manifest)
        return;
    const availableSpec = manifest_utils_1.getSpecFromPackageManifest(opts.manifest, opts.linkedPkgName);
    if (availableSpec) {
        projectSnapshot.specifiers[opts.linkedPkgName] = availableSpec;
    }
    else {
        delete projectSnapshot.specifiers[opts.linkedPkgName];
    }
}
async function linkFromGlobal(pkgNames, linkTo, maybeOpts) {
    const reporter = maybeOpts === null || maybeOpts === void 0 ? void 0 : maybeOpts.reporter;
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.on('data', reporter);
    }
    const opts = await options_1.extendOptions(maybeOpts);
    const globalPkgPath = pathAbsolute(maybeOpts.globalDir);
    const linkFromPkgs = pkgNames.map((pkgName) => path.join(globalPkgPath, 'node_modules', pkgName));
    const newManifest = await link(linkFromPkgs, path.join(linkTo, 'node_modules'), opts);
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.removeListener('data', reporter);
    }
    return newManifest;
}
exports.linkFromGlobal = linkFromGlobal;
async function linkToGlobal(linkFrom, maybeOpts) {
    var _a;
    const reporter = maybeOpts === null || maybeOpts === void 0 ? void 0 : maybeOpts.reporter;
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.on('data', reporter);
    }
    maybeOpts.lockfileDir = (_a = maybeOpts.lockfileDir) !== null && _a !== void 0 ? _a : maybeOpts.globalDir;
    const opts = await options_1.extendOptions(maybeOpts);
    const globalPkgPath = pathAbsolute(maybeOpts.globalDir);
    const newManifest = await link([linkFrom], path.join(globalPkgPath, 'node_modules'), {
        ...opts,
        dir: maybeOpts.globalDir,
        linkToBin: maybeOpts.globalBin,
    });
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.removeListener('data', reporter);
    }
    return newManifest;
}
exports.linkToGlobal = linkToGlobal;
//# sourceMappingURL=index.js.map