"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDependenciesToPackage = exports.mutateModules = exports.install = void 0;
const build_modules_1 = __importStar(require("@pnpm/build-modules"));
const constants_1 = require("@pnpm/constants");
const core_loggers_1 = require("@pnpm/core-loggers");
const error_1 = __importDefault(require("@pnpm/error"));
const get_context_1 = __importDefault(require("@pnpm/get-context"));
const headless_1 = __importDefault(require("@pnpm/headless"));
const lifecycle_1 = require("@pnpm/lifecycle");
const link_bins_1 = __importDefault(require("@pnpm/link-bins"));
const lockfile_file_1 = require("@pnpm/lockfile-file");
const logger_1 = __importStar(require("@pnpm/logger"));
const manifest_utils_1 = require("@pnpm/manifest-utils");
const modules_yaml_1 = require("@pnpm/modules-yaml");
const read_modules_dir_1 = __importDefault(require("@pnpm/read-modules-dir"));
const remove_bins_1 = require("@pnpm/remove-bins");
const resolve_dependencies_1 = __importDefault(require("@pnpm/resolve-dependencies"));
const parseWantedDependencies_1 = __importDefault(require("../parseWantedDependencies"));
const safeIsInnerLink_1 = __importDefault(require("../safeIsInnerLink"));
const removeDeps_1 = __importDefault(require("../uninstall/removeDeps"));
const allProjectsAreUpToDate_1 = __importDefault(require("./allProjectsAreUpToDate"));
const extendInstallOptions_1 = __importDefault(require("./extendInstallOptions"));
const getPreferredVersions_1 = __importStar(require("./getPreferredVersions"));
const getWantedDependencies_1 = __importDefault(require("./getWantedDependencies"));
const link_1 = __importDefault(require("./link"));
const path = require("path");
const rimraf = require("@zkochan/rimraf");
const isInnerLink = require("is-inner-link");
const pFilter = require("p-filter");
const pLimit = require("p-limit");
const R = require("ramda");
async function install(manifest, opts) {
    var _a;
    const projects = await mutateModules([
        {
            buildIndex: 0,
            manifest,
            mutation: 'install',
            rootDir: (_a = opts.dir) !== null && _a !== void 0 ? _a : process.cwd(),
        },
    ], opts);
    return projects[0].manifest;
}
exports.install = install;
async function mutateModules(projects, maybeOpts) {
    const reporter = maybeOpts === null || maybeOpts === void 0 ? void 0 : maybeOpts.reporter;
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.on('data', reporter);
    }
    const opts = await extendInstallOptions_1.default(maybeOpts);
    if (!opts.include.dependencies && opts.include.optionalDependencies) {
        throw new error_1.default('OPTIONAL_DEPS_REQUIRE_PROD_DEPS', 'Optional dependencies cannot be installed without production dependencies');
    }
    const installsOnly = projects.every((project) => project.mutation === 'install');
    opts['forceNewModules'] = installsOnly;
    const ctx = await get_context_1.default(projects, opts);
    for (const { manifest, rootDir } of ctx.projects) {
        if (!manifest) {
            throw new Error(`No package.json found in "${rootDir}"`);
        }
    }
    const result = await _install();
    if (reporter && typeof reporter === 'function') {
        logger_1.streamParser.removeListener('data', reporter);
    }
    return result;
    async function _install() {
        var _a, _b, _c;
        const frozenLockfile = opts.frozenLockfile ||
            opts.frozenLockfileIfExists && ctx.existsWantedLockfile;
        if (!opts.lockfileOnly &&
            !opts.update &&
            installsOnly &&
            (frozenLockfile ||
                opts.preferFrozenLockfile &&
                    (!opts.pruneLockfileImporters || Object.keys(ctx.wantedLockfile.importers).length === ctx.projects.length) &&
                    ctx.existsWantedLockfile &&
                    ctx.wantedLockfile.lockfileVersion === constants_1.LOCKFILE_VERSION &&
                    await allProjectsAreUpToDate_1.default(ctx.projects, {
                        linkWorkspacePackages: opts.linkWorkspacePackagesDepth >= 0,
                        wantedLockfile: ctx.wantedLockfile,
                        workspacePackages: opts.workspacePackages,
                    }))) {
            if (!ctx.existsWantedLockfile) {
                if (ctx.projects.some((project) => pkgHasDependencies(project.manifest))) {
                    throw new Error(`Headless installation requires a ${constants_1.WANTED_LOCKFILE} file`);
                }
            }
            else {
                logger_1.default.info({ message: 'Lockfile is up-to-date, resolution step is skipped', prefix: opts.lockfileDir });
                try {
                    await headless_1.default({
                        currentEngine: {
                            nodeVersion: opts.nodeVersion,
                            pnpmVersion: opts.packageManager.name === 'pnpm' ? opts.packageManager.version : '',
                        },
                        currentLockfile: ctx.currentLockfile,
                        engineStrict: opts.engineStrict,
                        extraBinPaths: opts.extraBinPaths,
                        force: opts.force,
                        hoistedDependencies: ctx.hoistedDependencies,
                        hoistPattern: ctx.hoistPattern,
                        ignoreScripts: opts.ignoreScripts,
                        include: opts.include,
                        lockfileDir: ctx.lockfileDir,
                        modulesDir: opts.modulesDir,
                        ownLifecycleHooksStdio: opts.ownLifecycleHooksStdio,
                        packageManager: opts.packageManager,
                        pendingBuilds: ctx.pendingBuilds,
                        projects: ctx.projects,
                        pruneStore: opts.pruneStore,
                        publicHoistPattern: ctx.publicHoistPattern,
                        rawConfig: opts.rawConfig,
                        registries: opts.registries,
                        sideEffectsCacheRead: opts.sideEffectsCacheRead,
                        sideEffectsCacheWrite: opts.sideEffectsCacheWrite,
                        skipped: ctx.skipped,
                        storeController: opts.storeController,
                        storeDir: opts.storeDir,
                        unsafePerm: opts.unsafePerm,
                        userAgent: opts.userAgent,
                        virtualStoreDir: ctx.virtualStoreDir,
                        wantedLockfile: ctx.wantedLockfile,
                    });
                    return projects;
                }
                catch (error) {
                    if (frozenLockfile || error.code !== 'ERR_PNPM_LOCKFILE_MISSING_DEPENDENCY')
                        throw error;
                    // A broken lockfile may be caused by a badly resolved Git conflict
                    logger_1.default.warn({
                        error,
                        message: 'The lockfile is broken! Resolution step will be performed to fix it.',
                        prefix: ctx.lockfileDir,
                    });
                }
            }
        }
        const projectsToInstall = [];
        const projectsToBeInstalled = ctx.projects.filter(({ mutation }) => mutation === 'install');
        const scriptsOpts = {
            extraBinPaths: opts.extraBinPaths,
            rawConfig: opts.rawConfig,
            stdio: opts.ownLifecycleHooksStdio,
            unsafePerm: opts.unsafePerm || false,
        };
        if (!opts.ignoreScripts) {
            await lifecycle_1.runLifecycleHooksConcurrently(['preinstall'], projectsToBeInstalled, opts.childConcurrency, scriptsOpts);
        }
        // TODO: make it concurrent
        for (const project of ctx.projects) {
            switch (project.mutation) {
                case 'uninstallSome':
                    projectsToInstall.push({
                        pruneDirectDependencies: false,
                        ...project,
                        removePackages: project.dependencyNames,
                        updatePackageManifest: true,
                        wantedDependencies: [],
                    });
                    break;
                case 'install': {
                    await installCase({
                        ...project,
                        updatePackageManifest: (_a = opts.updatePackageManifest) !== null && _a !== void 0 ? _a : opts.update,
                    });
                    break;
                }
                case 'installSome': {
                    await installSome({
                        ...project,
                        updatePackageManifest: opts.updatePackageManifest !== false,
                    });
                    break;
                }
                case 'unlink': {
                    const packageDirs = await read_modules_dir_1.default(project.modulesDir);
                    const externalPackages = await pFilter(packageDirs, (packageDir) => isExternalLink(ctx.storeDir, project.modulesDir, packageDir));
                    const allDeps = manifest_utils_1.getAllDependenciesFromManifest(project.manifest);
                    const packagesToInstall = [];
                    for (const pkgName of externalPackages) {
                        await rimraf(path.join(project.modulesDir, pkgName));
                        if (allDeps[pkgName]) {
                            packagesToInstall.push(pkgName);
                        }
                    }
                    if (!packagesToInstall.length)
                        return projects;
                    // TODO: install only those that were unlinked
                    // but don't update their version specs in package.json
                    await installCase({ ...project, mutation: 'install' });
                    break;
                }
                case 'unlinkSome': {
                    if (((_b = project.manifest) === null || _b === void 0 ? void 0 : _b.name) && opts.globalBin) {
                        await remove_bins_1.removeBin(path.join(opts.globalBin, (_c = project.manifest) === null || _c === void 0 ? void 0 : _c.name));
                    }
                    const packagesToInstall = [];
                    const allDeps = manifest_utils_1.getAllDependenciesFromManifest(project.manifest);
                    for (const depName of project.dependencyNames) {
                        try {
                            if (!await isExternalLink(ctx.storeDir, project.modulesDir, depName)) {
                                logger_1.default.warn({
                                    message: `${depName} is not an external link`,
                                    prefix: project.rootDir,
                                });
                                continue;
                            }
                        }
                        catch (err) {
                            if (err['code'] !== 'ENOENT')
                                throw err; // eslint-disable-line @typescript-eslint/dot-notation
                        }
                        await rimraf(path.join(project.modulesDir, depName));
                        if (allDeps[depName]) {
                            packagesToInstall.push(depName);
                        }
                    }
                    if (!packagesToInstall.length)
                        return projects;
                    // TODO: install only those that were unlinked
                    // but don't update their version specs in package.json
                    await installSome({
                        ...project,
                        dependencySelectors: packagesToInstall,
                        mutation: 'installSome',
                        updatePackageManifest: false,
                    });
                    break;
                }
            }
        }
        async function installCase(project) {
            var _a, _b, _c, _d;
            const wantedDependencies = getWantedDependencies_1.default(project.manifest, {
                includeDirect: opts.includeDirect,
                updateWorkspaceDependencies: opts.update,
            })
                .map((wantedDependency) => ({ ...wantedDependency, updateSpec: true }));
            if ((_a = ctx.wantedLockfile) === null || _a === void 0 ? void 0 : _a.importers) {
                forgetResolutionsOfPrevWantedDeps(ctx.wantedLockfile.importers[project.id], wantedDependencies);
            }
            const scripts = opts.ignoreScripts ? {} : ((_c = (_b = project.manifest) === null || _b === void 0 ? void 0 : _b.scripts) !== null && _c !== void 0 ? _c : {});
            if (opts.ignoreScripts && ((_d = project.manifest) === null || _d === void 0 ? void 0 : _d.scripts) &&
                (project.manifest.scripts.preinstall || project.manifest.scripts.prepublish ||
                    project.manifest.scripts.install ||
                    project.manifest.scripts.postinstall ||
                    project.manifest.scripts.prepare)) {
                ctx.pendingBuilds.push(project.id);
            }
            if (scripts['prepublish']) { // eslint-disable-line @typescript-eslint/dot-notation
                logger_1.default.warn({
                    message: '`prepublish` scripts are deprecated. Use `prepare` for build steps and `prepublishOnly` for upload-only.',
                    prefix: project.rootDir,
                });
            }
            projectsToInstall.push({
                pruneDirectDependencies: false,
                ...project,
                wantedDependencies,
            });
        }
        async function installSome(project) {
            const currentPrefs = opts.ignoreCurrentPrefs ? {} : manifest_utils_1.getAllDependenciesFromManifest(project.manifest);
            const optionalDependencies = project.targetDependenciesField ? {} : project.manifest.optionalDependencies || {};
            const devDependencies = project.targetDependenciesField ? {} : project.manifest.devDependencies || {};
            const wantedDeps = parseWantedDependencies_1.default(project.dependencySelectors, {
                allowNew: project.allowNew !== false,
                currentPrefs,
                defaultTag: opts.tag,
                dev: project.targetDependenciesField === 'devDependencies',
                devDependencies,
                optional: project.targetDependenciesField === 'optionalDependencies',
                optionalDependencies,
                updateWorkspaceDependencies: opts.update,
            });
            projectsToInstall.push({
                pruneDirectDependencies: false,
                ...project,
                wantedDependencies: wantedDeps.map(wantedDep => ({ ...wantedDep, isNew: true, updateSpec: true })),
            });
        }
        // Unfortunately, the private lockfile may differ from the public one.
        // A user might run named installations on a project that has a pnpm-lock.yaml file before running a noop install
        const makePartialCurrentLockfile = !installsOnly && (ctx.existsWantedLockfile && !ctx.existsCurrentLockfile ||
            !ctx.currentLockfileIsUpToDate);
        const result = await installInContext(projectsToInstall, ctx, {
            ...opts,
            currentLockfileIsUpToDate: !ctx.existsWantedLockfile || ctx.currentLockfileIsUpToDate,
            makePartialCurrentLockfile,
            update: opts.update || !installsOnly,
            updateLockfileMinorVersion: true,
        });
        if (!opts.ignoreScripts) {
            await lifecycle_1.runLifecycleHooksConcurrently(['install', 'postinstall', 'prepublish', 'prepare'], projectsToBeInstalled, opts.childConcurrency, scriptsOpts);
        }
        return result;
    }
}
exports.mutateModules = mutateModules;
async function isExternalLink(storeDir, modules, pkgName) {
    const link = await isInnerLink(modules, pkgName);
    return !link.isInner;
}
function pkgHasDependencies(manifest) {
    return Boolean(R.keys(manifest.dependencies).length ||
        R.keys(manifest.devDependencies).length ||
        R.keys(manifest.optionalDependencies).length);
}
async function partitionLinkedPackages(dependencies, opts) {
    var _a;
    const nonLinkedDependencies = [];
    const linkedAliases = new Set();
    for (const dependency of dependencies) {
        if (!dependency.alias || ((_a = opts.workspacePackages) === null || _a === void 0 ? void 0 : _a[dependency.alias])) {
            nonLinkedDependencies.push(dependency);
            continue;
        }
        const isInnerLink = await safeIsInnerLink_1.default(opts.modulesDir, dependency.alias, {
            hideAlienModules: !opts.lockfileOnly,
            projectDir: opts.projectDir,
            storeDir: opts.storeDir,
            virtualStoreDir: opts.virtualStoreDir,
        });
        if (isInnerLink === true) {
            nonLinkedDependencies.push(dependency);
            continue;
        }
        // This info-log might be better to be moved to the reporter
        logger_1.default.info({
            message: `${dependency.alias} is linked to ${opts.modulesDir} from ${isInnerLink}`,
            prefix: opts.projectDir,
        });
        linkedAliases.add(dependency.alias);
    }
    return {
        linkedAliases,
        nonLinkedDependencies,
    };
}
// If the specifier is new, the old resolution probably does not satisfy it anymore.
// By removing these resolutions we ensure that they are resolved again using the new specs.
function forgetResolutionsOfPrevWantedDeps(importer, wantedDeps) {
    var _a, _b, _c, _d;
    if (!importer.specifiers)
        return;
    importer.dependencies = (_a = importer.dependencies) !== null && _a !== void 0 ? _a : {};
    importer.devDependencies = (_b = importer.devDependencies) !== null && _b !== void 0 ? _b : {};
    importer.optionalDependencies = (_c = importer.optionalDependencies) !== null && _c !== void 0 ? _c : {};
    for (const { alias, pref } of wantedDeps) {
        if (alias && importer.specifiers[alias] !== pref) {
            if (!((_d = importer.dependencies[alias]) === null || _d === void 0 ? void 0 : _d.startsWith('link:'))) {
                delete importer.dependencies[alias];
            }
            delete importer.devDependencies[alias];
            delete importer.optionalDependencies[alias];
        }
    }
}
async function addDependenciesToPackage(manifest, dependencySelectors, opts) {
    var _a, _b;
    const projects = await mutateModules([
        {
            allowNew: opts.allowNew,
            dependencySelectors,
            manifest,
            mutation: 'installSome',
            peer: opts.peer,
            pinnedVersion: opts.pinnedVersion,
            rootDir: (_a = opts.dir) !== null && _a !== void 0 ? _a : process.cwd(),
            targetDependenciesField: opts.targetDependenciesField,
        },
    ], {
        ...opts,
        lockfileDir: (_b = opts.lockfileDir) !== null && _b !== void 0 ? _b : opts.dir,
    });
    return projects[0].manifest;
}
exports.addDependenciesToPackage = addDependenciesToPackage;
async function installInContext(projects, ctx, opts) {
    var _a, _b, _c, _d, _e, _f;
    if (opts.lockfileOnly && ctx.existsCurrentLockfile) {
        logger_1.default.warn({
            message: '`node_modules` is present. Lockfile only installation will make it out-of-date',
            prefix: ctx.lockfileDir,
        });
    }
    ctx.wantedLockfile.importers = ctx.wantedLockfile.importers || {};
    for (const { id } of projects) {
        if (!ctx.wantedLockfile.importers[id]) {
            ctx.wantedLockfile.importers[id] = { specifiers: {} };
        }
    }
    if (opts.pruneLockfileImporters) {
        const projectIds = new Set(projects.map(({ id }) => id));
        for (const wantedImporter of Object.keys(ctx.wantedLockfile.importers)) {
            if (!projectIds.has(wantedImporter)) {
                delete ctx.wantedLockfile.importers[wantedImporter];
            }
        }
    }
    await Promise.all(projects
        .map(async (project) => {
        if (project.mutation !== 'uninstallSome')
            return;
        const _removeDeps = (manifest) => removeDeps_1.default(manifest, project.dependencyNames, { prefix: project.rootDir, saveType: project.targetDependenciesField });
        project.manifest = await _removeDeps(project.manifest);
        if (project.originalManifest) {
            project.originalManifest = await _removeDeps(project.originalManifest);
        }
    }));
    core_loggers_1.stageLogger.debug({
        prefix: ctx.lockfileDir,
        stage: 'resolution_started',
    });
    const preferredVersions = (_a = opts.preferredVersions) !== null && _a !== void 0 ? _a : ((!opts.update &&
        ctx.wantedLockfile.packages &&
        !R.isEmpty(ctx.wantedLockfile.packages)) ? getPreferredVersions_1.getPreferredVersionsFromLockfile(ctx.wantedLockfile.packages) : undefined);
    const forceFullResolution = ctx.wantedLockfile.lockfileVersion !== constants_1.LOCKFILE_VERSION ||
        !opts.currentLockfileIsUpToDate ||
        opts.force;
    const _toResolveImporter = toResolveImporter.bind(null, {
        defaultUpdateDepth: (opts.update || opts.updateMatching) ? opts.depth : -1,
        lockfileOnly: opts.lockfileOnly,
        preferredVersions,
        storeDir: ctx.storeDir,
        updateAll: Boolean(opts.updateMatching),
        virtualStoreDir: ctx.virtualStoreDir,
        workspacePackages: opts.workspacePackages,
    });
    const projectsToResolve = await Promise.all(projects.map((project) => _toResolveImporter(project)));
    let { dependenciesGraph, dependenciesByProjectId, finishLockfileUpdates, linkedDependenciesByProjectId, newLockfile, outdatedDependencies, wantedToBeSkippedPackageIds, waitTillAllFetchingsFinish, } = await resolve_dependencies_1.default(projectsToResolve, {
        currentLockfile: ctx.currentLockfile,
        dryRun: opts.lockfileOnly,
        engineStrict: opts.engineStrict,
        force: opts.force,
        forceFullResolution,
        hooks: opts.hooks,
        linkWorkspacePackagesDepth: (_b = opts.linkWorkspacePackagesDepth) !== null && _b !== void 0 ? _b : (opts.saveWorkspaceProtocol ? 0 : -1),
        lockfileDir: opts.lockfileDir,
        nodeVersion: opts.nodeVersion,
        pnpmVersion: opts.packageManager.name === 'pnpm' ? opts.packageManager.version : '',
        preserveWorkspaceProtocol: opts.preserveWorkspaceProtocol,
        registries: opts.registries,
        saveWorkspaceProtocol: opts.saveWorkspaceProtocol,
        storeController: opts.storeController,
        strictPeerDependencies: opts.strictPeerDependencies,
        tag: opts.tag,
        updateMatching: opts.updateMatching,
        virtualStoreDir: ctx.virtualStoreDir,
        wantedLockfile: ctx.wantedLockfile,
        workspacePackages: opts.workspacePackages,
    });
    core_loggers_1.stageLogger.debug({
        prefix: ctx.lockfileDir,
        stage: 'resolution_done',
    });
    newLockfile = ((_c = opts.hooks) === null || _c === void 0 ? void 0 : _c.afterAllResolved) ? (_d = opts.hooks) === null || _d === void 0 ? void 0 : _d.afterAllResolved(newLockfile) : newLockfile;
    if (opts.updateLockfileMinorVersion) {
        newLockfile.lockfileVersion = constants_1.LOCKFILE_VERSION;
    }
    const lockfileOpts = { forceSharedFormat: opts.forceSharedLockfile };
    if (!opts.lockfileOnly) {
        const result = await link_1.default(projectsToResolve, dependenciesGraph, {
            currentLockfile: ctx.currentLockfile,
            dependenciesByProjectId,
            force: opts.force,
            hoistedDependencies: ctx.hoistedDependencies,
            hoistedModulesDir: ctx.hoistedModulesDir,
            hoistPattern: ctx.hoistPattern,
            include: opts.include,
            linkedDependenciesByProjectId,
            lockfileDir: opts.lockfileDir,
            makePartialCurrentLockfile: opts.makePartialCurrentLockfile,
            outdatedDependencies,
            pruneStore: opts.pruneStore,
            publicHoistPattern: ctx.publicHoistPattern,
            registries: ctx.registries,
            rootModulesDir: ctx.rootModulesDir,
            sideEffectsCacheRead: opts.sideEffectsCacheRead,
            skipped: ctx.skipped,
            storeController: opts.storeController,
            strictPeerDependencies: opts.strictPeerDependencies,
            virtualStoreDir: ctx.virtualStoreDir,
            wantedLockfile: newLockfile,
            wantedToBeSkippedPackageIds,
        });
        await finishLockfileUpdates();
        ctx.pendingBuilds = ctx.pendingBuilds
            .filter((relDepPath) => !result.removedDepPaths.has(relDepPath));
        if (opts.ignoreScripts) {
            // we can use concat here because we always only append new packages, which are guaranteed to not be there by definition
            ctx.pendingBuilds = ctx.pendingBuilds
                .concat(result.newDepPaths
                .filter((depPath) => dependenciesGraph[depPath].requiresBuild));
        }
        else if ((_e = result.newDepPaths) === null || _e === void 0 ? void 0 : _e.length) {
            // postinstall hooks
            const depPaths = Object.keys(dependenciesGraph);
            const rootNodes = depPaths.filter((depPath) => dependenciesGraph[depPath].depth === 0);
            await build_modules_1.default(dependenciesGraph, rootNodes, {
                childConcurrency: opts.childConcurrency,
                depsToBuild: new Set(result.newDepPaths),
                extraBinPaths: ctx.extraBinPaths,
                lockfileDir: ctx.lockfileDir,
                optional: opts.include.optionalDependencies,
                rawConfig: opts.rawConfig,
                rootModulesDir: ctx.virtualStoreDir,
                sideEffectsCacheWrite: opts.sideEffectsCacheWrite,
                storeController: opts.storeController,
                unsafePerm: opts.unsafePerm,
                userAgent: opts.userAgent,
            });
        }
        if ((_f = result.newDepPaths) === null || _f === void 0 ? void 0 : _f.length) {
            const newPkgs = R.props(result.newDepPaths, dependenciesGraph);
            await linkAllBins(newPkgs, dependenciesGraph, {
                optional: opts.include.optionalDependencies,
                warn: (message) => logger_1.default.warn({ message, prefix: opts.lockfileDir }),
            });
        }
        await Promise.all(projectsToResolve.map(async (project, index) => {
            const linkedPackages = await linkBinsOfImporter(project);
            const projectToInstall = projects[index];
            if (opts.global && projectToInstall.mutation.includes('install')) {
                projectToInstall.wantedDependencies.forEach(pkg => {
                    if (!(linkedPackages === null || linkedPackages === void 0 ? void 0 : linkedPackages.includes(pkg.alias))) {
                        logger_1.default.warn({ message: `${pkg.alias} has no binaries`, prefix: opts.lockfileDir });
                    }
                });
            }
        }));
        await Promise.all([
            opts.useLockfile
                ? lockfile_file_1.writeLockfiles({
                    currentLockfile: result.currentLockfile,
                    currentLockfileDir: ctx.virtualStoreDir,
                    wantedLockfile: newLockfile,
                    wantedLockfileDir: ctx.lockfileDir,
                    ...lockfileOpts,
                })
                : lockfile_file_1.writeCurrentLockfile(ctx.virtualStoreDir, result.currentLockfile, lockfileOpts),
            (() => {
                if (result.currentLockfile.packages === undefined && result.removedDepPaths.size === 0) {
                    return Promise.resolve();
                }
                return modules_yaml_1.write(ctx.rootModulesDir, {
                    ...ctx.modulesFile,
                    hoistedDependencies: result.newHoistedDependencies,
                    hoistPattern: ctx.hoistPattern,
                    included: ctx.include,
                    layoutVersion: constants_1.LAYOUT_VERSION,
                    packageManager: `${opts.packageManager.name}@${opts.packageManager.version}`,
                    pendingBuilds: ctx.pendingBuilds,
                    publicHoistPattern: ctx.publicHoistPattern,
                    registries: ctx.registries,
                    skipped: Array.from(ctx.skipped),
                    storeDir: ctx.storeDir,
                    virtualStoreDir: ctx.virtualStoreDir,
                });
            })(),
        ]);
    }
    else {
        await finishLockfileUpdates();
        await lockfile_file_1.writeWantedLockfile(ctx.lockfileDir, newLockfile, lockfileOpts);
        // This is only needed because otherwise the reporter will hang
        core_loggers_1.stageLogger.debug({
            prefix: opts.lockfileDir,
            stage: 'importing_done',
        });
    }
    await waitTillAllFetchingsFinish();
    core_loggers_1.summaryLogger.debug({ prefix: opts.lockfileDir });
    await opts.storeController.close();
    return projectsToResolve.map(({ manifest, rootDir }) => ({ rootDir, manifest }));
}
async function toResolveImporter(opts, project) {
    var _a, _b, _c;
    const allDeps = getWantedDependencies_1.default(project.manifest);
    const { linkedAliases, nonLinkedDependencies } = await partitionLinkedPackages(allDeps, {
        lockfileOnly: opts.lockfileOnly,
        modulesDir: project.modulesDir,
        projectDir: project.rootDir,
        storeDir: opts.storeDir,
        virtualStoreDir: opts.virtualStoreDir,
        workspacePackages: opts.workspacePackages,
    });
    const existingDeps = nonLinkedDependencies
        .filter(({ alias }) => !project.wantedDependencies.some((wantedDep) => wantedDep.alias === alias));
    let wantedDependencies;
    if (!project.manifest) {
        wantedDependencies = [
            ...project.wantedDependencies,
            ...existingDeps,
        ]
            .map((dep) => ({
            ...dep,
            updateDepth: opts.defaultUpdateDepth,
        }));
    }
    else {
        // Direct local tarballs are always checked,
        // so their update depth should be at least 0
        const updateLocalTarballs = (dep) => ({
            ...dep,
            updateDepth: opts.updateAll
                ? opts.defaultUpdateDepth : (prefIsLocalTarball(dep.pref) ? 0 : -1),
        });
        wantedDependencies = [
            ...project.wantedDependencies.map(opts.defaultUpdateDepth < 0
                ? updateLocalTarballs
                : (dep) => ({ ...dep, updateDepth: opts.defaultUpdateDepth })),
            ...existingDeps.map(updateLocalTarballs),
        ];
    }
    return {
        ...project,
        hasRemovedDependencies: Boolean((_a = project.removePackages) === null || _a === void 0 ? void 0 : _a.length),
        preferredVersions: (_c = (_b = opts.preferredVersions) !== null && _b !== void 0 ? _b : (project.manifest && getPreferredVersions_1.default(project.manifest))) !== null && _c !== void 0 ? _c : {},
        wantedDependencies: wantedDependencies
            .filter(({ alias, updateDepth }) => updateDepth >= 0 || !linkedAliases.has(alias)),
    };
}
function prefIsLocalTarball(pref) {
    return pref.startsWith('file:') && pref.endsWith('.tgz');
}
const limitLinking = pLimit(16);
function linkBinsOfImporter({ modulesDir, binsDir, rootDir }) {
    const warn = (message) => logger_1.default.info({ message, prefix: rootDir });
    return link_bins_1.default(modulesDir, binsDir, { allowExoticManifests: true, warn });
}
function linkAllBins(depNodes, depGraph, opts) {
    return Promise.all(depNodes.map(depNode => limitLinking(() => build_modules_1.linkBinsOfDependencies(depNode, depGraph, opts))));
}
//# sourceMappingURL=index.js.map