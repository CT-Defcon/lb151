"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@pnpm/logger"));
const prune_lockfile_1 = require("@pnpm/prune-lockfile");
const dp = __importStar(require("dependency-path"));
const get_npm_tarball_url_1 = __importDefault(require("get-npm-tarball-url"));
const R = __importStar(require("ramda"));
const depPathToRef_1 = __importDefault(require("./depPathToRef"));
function default_1(depGraph, lockfile, prefix, registries) {
    var _a;
    lockfile.packages = (_a = lockfile.packages) !== null && _a !== void 0 ? _a : {};
    const pendingRequiresBuilds = [];
    for (const depPath of Object.keys(depGraph)) {
        const depNode = depGraph[depPath];
        const [updatedOptionalDeps, updatedDeps] = R.partition((child) => depNode.optionalDependencies.has(child.alias), Object.keys(depNode.children).map((alias) => ({ alias, depPath: depNode.children[alias] })));
        lockfile.packages[depPath] = toLockfileDependency(pendingRequiresBuilds, depNode, {
            depGraph,
            depPath,
            prevSnapshot: lockfile.packages[depPath],
            registries,
            registry: dp.getRegistryByPackageName(registries, depNode.name),
            updatedDeps,
            updatedOptionalDeps,
        });
    }
    const warn = (message) => logger_1.default.warn({ message, prefix });
    return {
        newLockfile: prune_lockfile_1.pruneSharedLockfile(lockfile, { warn }),
        pendingRequiresBuilds,
    };
}
exports.default = default_1;
function toLockfileDependency(pendingRequiresBuilds, pkg, opts) {
    var _a, _b, _c, _d, _e, _f;
    const lockfileResolution = toLockfileResolution({ name: pkg.name, version: pkg.version }, opts.depPath, pkg.resolution, opts.registry);
    const newResolvedDeps = updateResolvedDeps((_b = (_a = opts.prevSnapshot) === null || _a === void 0 ? void 0 : _a.dependencies) !== null && _b !== void 0 ? _b : {}, opts.updatedDeps, opts.registries, opts.depGraph);
    const newResolvedOptionalDeps = updateResolvedDeps((_d = (_c = opts.prevSnapshot) === null || _c === void 0 ? void 0 : _c.optionalDependencies) !== null && _d !== void 0 ? _d : {}, opts.updatedOptionalDeps, opts.registries, opts.depGraph);
    const result = {
        resolution: lockfileResolution,
    };
    /* eslint-disable @typescript-eslint/dot-notation */
    if (dp.isAbsolute(opts.depPath)) {
        result['name'] = pkg.name;
        // There is no guarantee that a non-npmjs.org-hosted package
        // is going to have a version field
        if (pkg.version) {
            result['version'] = pkg.version;
        }
    }
    if (!R.isEmpty(newResolvedDeps)) {
        result['dependencies'] = newResolvedDeps;
    }
    if (!R.isEmpty(newResolvedOptionalDeps)) {
        result['optionalDependencies'] = newResolvedOptionalDeps;
    }
    if (pkg.dev && !pkg.prod) {
        result['dev'] = true;
    }
    else if (pkg.prod && !pkg.dev) {
        result['dev'] = false;
    }
    if (pkg.optional) {
        result['optional'] = true;
    }
    if (opts.depPath[0] !== '/' && !pkg.id.endsWith(opts.depPath)) {
        result['id'] = pkg.id;
    }
    if (!R.isEmpty((_e = pkg.peerDependencies) !== null && _e !== void 0 ? _e : {})) {
        result['peerDependencies'] = pkg.peerDependencies;
    }
    if (pkg.peerDependenciesMeta) {
        const normalizedPeerDependenciesMeta = {};
        for (const peer of Object.keys(pkg.peerDependenciesMeta)) {
            if (pkg.peerDependenciesMeta[peer].optional) {
                normalizedPeerDependenciesMeta[peer] = { optional: true };
            }
        }
        if (Object.keys(normalizedPeerDependenciesMeta).length) {
            result['peerDependenciesMeta'] = normalizedPeerDependenciesMeta;
        }
    }
    if (pkg.additionalInfo.engines) {
        for (const engine of R.keys(pkg.additionalInfo.engines)) {
            if (pkg.additionalInfo.engines[engine] === '*')
                continue;
            result['engines'] = result['engines'] || {};
            result['engines'][engine] = pkg.additionalInfo.engines[engine];
        }
    }
    if (pkg.additionalInfo.cpu) {
        result['cpu'] = pkg.additionalInfo.cpu;
    }
    if (pkg.additionalInfo.os) {
        result['os'] = pkg.additionalInfo.os;
    }
    if (Array.isArray(pkg.additionalInfo.bundledDependencies) || Array.isArray(pkg.additionalInfo.bundleDependencies)) {
        result['bundledDependencies'] = (_f = pkg.additionalInfo.bundledDependencies) !== null && _f !== void 0 ? _f : pkg.additionalInfo.bundleDependencies;
    }
    if (pkg.additionalInfo.deprecated) {
        result['deprecated'] = pkg.additionalInfo.deprecated;
    }
    if (pkg.hasBin) {
        result['hasBin'] = true;
    }
    if (opts.prevSnapshot) {
        if (opts.prevSnapshot.requiresBuild) {
            result['requiresBuild'] = opts.prevSnapshot.requiresBuild;
        }
        if (opts.prevSnapshot.prepare) {
            result['prepare'] = opts.prevSnapshot.prepare;
        }
    }
    else if (pkg.prepare) {
        result['prepare'] = true;
        result['requiresBuild'] = true;
    }
    else if (pkg.requiresBuild !== undefined) {
        if (pkg.requiresBuild) {
            result['requiresBuild'] = true;
        }
    }
    else {
        pendingRequiresBuilds.push(opts.depPath);
    }
    pkg.requiresBuild = result['requiresBuild'];
    /* eslint-enable @typescript-eslint/dot-notation */
    return result;
}
// previous resolutions should not be removed from lockfile
// as installation might not reanalize the whole dependency graph
// the `depth` property defines how deep should dependencies be checked
function updateResolvedDeps(prevResolvedDeps, updatedDeps, registries, depGraph) {
    const newResolvedDeps = R.fromPairs(updatedDeps
        .map(({ alias, depPath }) => {
        if (depPath.startsWith('link:')) {
            return [alias, depPath];
        }
        const depNode = depGraph[depPath];
        return [
            alias,
            depPathToRef_1.default(depNode.depPath, {
                alias,
                realName: depNode.name,
                registries,
                resolution: depNode.resolution,
            }),
        ];
    }));
    return R.merge(prevResolvedDeps, newResolvedDeps);
}
function toLockfileResolution(pkg, depPath, resolution, registry) {
    /* eslint-disable @typescript-eslint/dot-notation */
    if (dp.isAbsolute(depPath) || resolution.type !== undefined || !resolution['integrity']) {
        return resolution;
    }
    const base = registry !== resolution['registry'] ? { registry: resolution['registry'] } : {};
    // Sometimes packages are hosted under non-standard tarball URLs.
    // For instance, when they are hosted on npm Enterprise. See https://github.com/pnpm/pnpm/issues/867
    // Or in othere weird cases, like https://github.com/pnpm/pnpm/issues/1072
    const expectedTarball = get_npm_tarball_url_1.default(pkg.name, pkg.version, { registry });
    const actualTarball = resolution['tarball'].replace('%2f', '/');
    if (removeProtocol(expectedTarball) !== removeProtocol(actualTarball)) {
        return {
            ...base,
            integrity: resolution['integrity'],
            tarball: relativeTarball(resolution['tarball'], registry),
        };
    }
    return {
        ...base,
        integrity: resolution['integrity'],
    };
    /* eslint-enable @typescript-eslint/dot-notation */
}
function removeProtocol(url) {
    return url.split('://')[1];
}
function relativeTarball(tarball, registry) {
    // It is important to save the tarball URL as "relative-path" (without the leading '/').
    // Sometimes registries are located in a subdirectory of a website.
    // For instance, https://mycompany.jfrog.io/mycompany/api/npm/npm-local/
    // So the tarball location should be relative to the directory,
    // it is not an absolute-path reference.
    // So we add @mycompany/mypackage/-/@mycompany/mypackage-2.0.0.tgz
    // not /@mycompany/mypackage/-/@mycompany/mypackage-2.0.0.tgz
    // Related issue: https://github.com/pnpm/pnpm/issues/1827
    if (tarball.substr(0, registry.length) === registry) {
        return tarball.substr(registry.length);
    }
    return tarball;
}
//# sourceMappingURL=updateLockfile.js.map