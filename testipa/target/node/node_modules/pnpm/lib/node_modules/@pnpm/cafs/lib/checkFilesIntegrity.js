"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyFileIntegrity = void 0;
const parseJson_1 = require("./parseJson");
const getFilePathInCafs_1 = require("./getFilePathInCafs");
const rimraf = require("@zkochan/rimraf");
const fs = require("mz/fs");
const pLimit = require("p-limit");
const ssri = require("ssri");
const limit = pLimit(20);
const MAX_BULK_SIZE = 1 * 1024 * 1024; // 1MB
async function default_1(cafsDir, pkgIndex, manifest) {
    let verified = true;
    await Promise.all(Object.keys(pkgIndex)
        .map((f) => limit(async () => {
        const fstat = pkgIndex[f];
        if (!fstat.integrity) {
            throw new Error(`Integrity checksum is missing for ${f}`);
        }
        if (!await verifyFile(getFilePathInCafs_1.getFilePathByModeInCafs(cafsDir, fstat.integrity, fstat.mode), fstat, f === 'package.json' ? manifest : undefined)) {
            verified = false;
        }
    })));
    return verified;
}
exports.default = default_1;
async function verifyFile(filename, fstat, deferredManifest) {
    const currentFile = await checkFile(filename, fstat.checkedAt);
    if (!currentFile)
        return false;
    if (currentFile.isModified) {
        if (currentFile.size !== fstat.size) {
            await rimraf(filename);
            return false;
        }
        return verifyFileIntegrity(filename, fstat, deferredManifest);
    }
    if (deferredManifest) {
        parseJson_1.parseJsonBuffer(await fs.readFile(filename), deferredManifest);
    }
    // If a file was not edited, we are skipping integrity check.
    // We assume that nobody will manually remove a file in the store and create a new one.
    return true;
}
async function verifyFileIntegrity(filename, expectedFile, deferredManifest) {
    try {
        if (expectedFile.size > MAX_BULK_SIZE && !deferredManifest) {
            const ok = Boolean(await ssri.checkStream(fs.createReadStream(filename), expectedFile.integrity));
            if (!ok) {
                await rimraf(filename);
            }
            return ok;
        }
        const data = await fs.readFile(filename);
        const ok = Boolean(ssri.checkData(data, expectedFile.integrity));
        if (!ok) {
            await rimraf(filename);
        }
        else if (deferredManifest) {
            parseJson_1.parseJsonBuffer(data, deferredManifest);
        }
        return ok;
    }
    catch (err) {
        switch (err.code) {
            case 'ENOENT': return false;
            case 'EINTEGRITY': {
                // Broken files are removed from the store
                await rimraf(filename);
                return false;
            }
        }
        throw err;
    }
}
exports.verifyFileIntegrity = verifyFileIntegrity;
async function checkFile(filename, checkedAt) {
    try {
        const { mtimeMs, size } = await fs.stat(filename);
        return {
            isModified: (mtimeMs - (checkedAt !== null && checkedAt !== void 0 ? checkedAt : 0)) > 100,
            size,
        };
    }
    catch (err) {
        if (err.code === 'ENOENT')
            return null;
        throw err;
    }
}
//# sourceMappingURL=checkFilesIntegrity.js.map