"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.propertyByDependencyType = void 0;
const Rx = __importStar(require("rxjs"));
const operators_1 = require("rxjs/operators");
const R = require("ramda");
exports.propertyByDependencyType = {
    dev: 'devDependencies',
    nodeModulesOnly: 'node_modules',
    optional: 'optionalDependencies',
    peer: 'peerDependencies',
    prod: 'dependencies',
};
function default_1(log$, opts) {
    const deprecationSet$ = log$.deprecation
        .pipe(operators_1.filter((log) => log.prefix === opts.prefix), operators_1.scan((acc, log) => {
        acc.add(log.pkgId);
        return acc;
    }, new Set()), operators_1.startWith(new Set()));
    const filterPrefix = operators_1.filter((log) => log.prefix === opts.prefix);
    const pkgsDiff$ = Rx.combineLatest(log$.root.pipe(filterPrefix), deprecationSet$).pipe(operators_1.scan((pkgsDiff, args) => {
        const rootLog = args[0];
        const deprecationSet = args[1];
        if (rootLog['added']) {
            pkgsDiff[rootLog['added'].dependencyType || 'nodeModulesOnly'][`+${rootLog['added'].name}`] = {
                added: true,
                deprecated: deprecationSet.has(rootLog['added'].id),
                from: rootLog['added'].linkedFrom,
                latest: rootLog['added'].latest,
                name: rootLog['added'].name,
                realName: rootLog['added'].realName,
                version: rootLog['added'].version,
            };
            return pkgsDiff;
        }
        if (rootLog['removed']) {
            pkgsDiff[rootLog['removed'].dependencyType || 'nodeModulesOnly'][`-${rootLog['removed'].name}`] = {
                added: false,
                name: rootLog['removed'].name,
                version: rootLog['removed'].version,
            };
            return pkgsDiff;
        }
        return pkgsDiff;
    }, {
        dev: {},
        nodeModulesOnly: {},
        optional: {},
        peer: {},
        prod: {},
    }), operators_1.startWith({
        dev: {},
        nodeModulesOnly: {},
        optional: {},
        peer: {},
        prod: {},
    }));
    const packageManifest$ = Rx.merge(log$.packageManifest.pipe(filterPrefix), log$.summary.pipe(filterPrefix, operators_1.mapTo({})))
        .pipe(operators_1.take(2), operators_1.reduce(R.merge, {}) // eslint-disable-line @typescript-eslint/no-explicit-any
    );
    return Rx.combineLatest(pkgsDiff$, packageManifest$)
        .pipe(operators_1.map(([pkgsDiff, packageManifests]) => {
        if (!packageManifests['initial'] || !packageManifests['updated'])
            return pkgsDiff;
        const initialPackageManifest = removeOptionalFromProdDeps(packageManifests['initial']);
        const updatedPackageManifest = removeOptionalFromProdDeps(packageManifests['updated']);
        for (const depType of ['peer', 'prod', 'optional', 'dev']) {
            const prop = exports.propertyByDependencyType[depType];
            const initialDeps = Object.keys(initialPackageManifest[prop] || {});
            const updatedDeps = Object.keys(updatedPackageManifest[prop] || {});
            const removedDeps = R.difference(initialDeps, updatedDeps);
            for (const removedDep of removedDeps) {
                if (!pkgsDiff[depType][`-${removedDep}`]) {
                    pkgsDiff[depType][`-${removedDep}`] = {
                        added: false,
                        name: removedDep,
                        version: initialPackageManifest[prop][removedDep],
                    };
                }
            }
            const addedDeps = R.difference(updatedDeps, initialDeps);
            for (const addedDep of addedDeps) {
                if (!pkgsDiff[depType][`+${addedDep}`]) {
                    pkgsDiff[depType][`+${addedDep}`] = {
                        added: true,
                        name: addedDep,
                        version: updatedPackageManifest[prop][addedDep],
                    };
                }
            }
        }
        return pkgsDiff;
    }));
}
exports.default = default_1;
function removeOptionalFromProdDeps(pkg) {
    if (!pkg.dependencies || !pkg.optionalDependencies)
        return pkg;
    for (const depName of Object.keys(pkg.dependencies)) {
        if (pkg.optionalDependencies[depName]) {
            delete pkg.dependencies[depName];
        }
    }
    return pkg;
}
//# sourceMappingURL=pkgsDiff.js.map