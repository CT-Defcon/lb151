"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("@pnpm/error");
const url = require("url");
// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
const semvarRegex = new RegExp(/(.*)(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/);
class RegistryResponseError extends error_1.FetchError {
    constructor(request, response, pkgName) {
        let hint;
        if (response.status === 404) {
            hint = `${pkgName} is not in the npm registry, or you have no permission to fetch it.`;
            const matched = pkgName.match(semvarRegex);
            if (matched) {
                hint += ` Did you mean ${matched[1]}?`;
            }
        }
        super(request, response, hint);
        this.pkgName = pkgName;
    }
}
async function fromRegistry(fetch, retry, pkgName, registry, authHeaderValue) {
    const uri = toUri(pkgName, registry);
    const response = await fetch(uri, { authHeaderValue, retry });
    if (response.status > 400) {
        const request = {
            authHeaderValue,
            url: uri,
        };
        throw new RegistryResponseError(request, response, pkgName);
    }
    return response.json();
}
exports.default = fromRegistry;
function toUri(pkgName, registry) {
    let encodedName;
    if (pkgName[0] === '@') {
        encodedName = `@${encodeURIComponent(pkgName.substr(1))}`;
    }
    else {
        encodedName = encodeURIComponent(pkgName);
    }
    return url.resolve(registry, encodedName);
}
//# sourceMappingURL=fetch.js.map