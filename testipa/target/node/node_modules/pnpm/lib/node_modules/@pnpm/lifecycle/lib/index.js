"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPostinstallHooks = exports.runLifecycleHooksConcurrently = void 0;
const read_package_json_1 = require("@pnpm/read-package-json");
const runLifecycleHook_1 = __importDefault(require("./runLifecycleHook"));
const runLifecycleHooksConcurrently_1 = __importDefault(require("./runLifecycleHooksConcurrently"));
exports.runLifecycleHooksConcurrently = runLifecycleHooksConcurrently_1.default;
const path = require("path");
const exists = require("path-exists");
exports.default = runLifecycleHook_1.default;
async function runPostinstallHooks(opts) {
    var _a;
    const pkg = await read_package_json_1.fromDir(opts.pkgRoot);
    const scripts = (_a = pkg === null || pkg === void 0 ? void 0 : pkg.scripts) !== null && _a !== void 0 ? _a : {};
    if (!scripts.install) {
        await checkBindingGyp(opts.pkgRoot, scripts);
    }
    if (scripts.preinstall) {
        await runLifecycleHook_1.default('preinstall', pkg, opts);
    }
    if (scripts.install) {
        await runLifecycleHook_1.default('install', pkg, opts);
    }
    if (scripts.postinstall) {
        await runLifecycleHook_1.default('postinstall', pkg, opts);
    }
    if (opts.prepare && scripts.prepare) {
        await runLifecycleHook_1.default('prepare', pkg, opts);
    }
    return !!scripts.preinstall || !!scripts.install || !!scripts.postinstall;
}
exports.runPostinstallHooks = runPostinstallHooks;
/**
 * Run node-gyp when binding.gyp is available. Only do this when there's no
 * `install` script (see `npm help scripts`).
 */
async function checkBindingGyp(root, scripts) {
    if (await exists(path.join(root, 'binding.gyp'))) {
        scripts['install'] = 'node-gyp rebuild'; // eslint-disable-line @typescript-eslint/dot-notation
    }
}
//# sourceMappingURL=index.js.map