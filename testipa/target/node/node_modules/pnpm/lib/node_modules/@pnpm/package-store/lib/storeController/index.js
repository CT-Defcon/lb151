"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cafs_1 = require("@pnpm/cafs");
const package_requester_1 = __importDefault(require("@pnpm/package-requester"));
const createImportPackage_1 = __importDefault(require("./createImportPackage"));
const prune_1 = __importDefault(require("./prune"));
const path = require("path");
const loadJsonFile = require("load-json-file");
const writeJsonFile = require("write-json-file");
async function default_1(resolve, fetchers, initOpts) {
    const storeDir = initOpts.storeDir;
    const packageRequester = package_requester_1.default(resolve, fetchers, {
        ignoreFile: initOpts.ignoreFile,
        networkConcurrency: initOpts.networkConcurrency,
        storeDir: initOpts.storeDir,
        verifyStoreIntegrity: initOpts.verifyStoreIntegrity,
    });
    const impPkg = createImportPackage_1.default(initOpts.packageImportMethod);
    const cafsDir = path.join(storeDir, 'files');
    const getFilePathByModeInCafs = cafs_1.getFilePathByModeInCafs.bind(null, cafsDir);
    const importPackage = async (to, opts) => {
        var _a, _b;
        const filesMap = {};
        let isBuilt;
        let filesIndex;
        if (opts.targetEngine && ((_a = opts.filesResponse.sideEffects) === null || _a === void 0 ? void 0 : _a[opts.targetEngine])) {
            filesIndex = (_b = opts.filesResponse.sideEffects) === null || _b === void 0 ? void 0 : _b[opts.targetEngine];
            isBuilt = true;
        }
        else {
            filesIndex = opts.filesResponse.filesIndex;
            isBuilt = false;
        }
        for (const [fileName, fileMeta] of Object.entries(filesIndex)) {
            filesMap[fileName] = getFilePathByModeInCafs(fileMeta.integrity, fileMeta.mode);
        }
        const importMethod = await impPkg(to, { filesMap, fromStore: opts.filesResponse.fromStore, force: opts.force });
        return { importMethod, isBuilt };
    };
    return {
        close: async () => { },
        fetchPackage: packageRequester.fetchPackageToStore,
        importPackage,
        prune: prune_1.default.bind(null, storeDir),
        requestPackage: packageRequester.requestPackage,
        upload,
    };
    async function upload(builtPkgLocation, opts) {
        var _a;
        const sideEffectsIndex = await packageRequester.cafs.addFilesFromDir(builtPkgLocation);
        // TODO: move this to a function
        // This is duplicated in @pnpm/package-requester
        const integrity = {};
        await Promise.all(Object.keys(sideEffectsIndex)
            .map(async (filename) => {
            const { checkedAt, integrity: fileIntegrity, } = await sideEffectsIndex[filename].writeResult;
            integrity[filename] = {
                checkedAt,
                integrity: fileIntegrity.toString(),
                mode: sideEffectsIndex[filename].mode,
                size: sideEffectsIndex[filename].size,
            };
        }));
        let filesIndex;
        try {
            filesIndex = await loadJsonFile(opts.filesIndexFile);
        }
        catch (err) {
            filesIndex = { files: integrity };
        }
        filesIndex.sideEffects = (_a = filesIndex.sideEffects) !== null && _a !== void 0 ? _a : {};
        filesIndex.sideEffects[opts.engine] = integrity;
        await writeJsonFile(opts.filesIndexFile, filesIndex, { indent: undefined });
    }
}
exports.default = default_1;
//# sourceMappingURL=index.js.map