"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_loggers_1 = require("@pnpm/core-loggers");
const lifecycle = require("@zkochan/npm-lifecycle");
function noop() { } // eslint-disable-line:no-empty
async function runLifecycleHook(stage, manifest, opts) {
    var _a, _b, _c, _d;
    const optional = opts.optional === true;
    const m = { _id: getId(manifest), ...manifest };
    m.scripts = { ...m.scripts };
    if (stage === 'start' && !m.scripts.start) {
        m.scripts.start = 'node server.js';
    }
    if (((_a = opts.args) === null || _a === void 0 ? void 0 : _a.length) && ((_b = m.scripts) === null || _b === void 0 ? void 0 : _b[stage])) {
        m.scripts[stage] = `${m.scripts[stage]} ${opts.args.map((arg) => `"${arg}"`).join(' ')}`;
    }
    // This script is used to prevent the usage of npm or Yarn.
    // It does nothing, when pnpm is used, so we may skip its execution.
    if (m.scripts[stage] === 'npx only-allow pnpm')
        return;
    if (opts.stdio !== 'inherit') {
        core_loggers_1.lifecycleLogger.debug({
            depPath: opts.depPath,
            optional,
            script: m.scripts[stage],
            stage,
            wd: opts.pkgRoot,
        });
    }
    const logLevel = (opts.stdio !== 'inherit' || opts.silent)
        ? 'silent' : undefined;
    await lifecycle(m, stage, opts.pkgRoot, {
        config: opts.rawConfig,
        dir: opts.rootModulesDir,
        extraBinPaths: (_c = opts.extraBinPaths) !== null && _c !== void 0 ? _c : [],
        extraEnv: { PNPM_SCRIPT_SRC_DIR: opts.pkgRoot },
        log: {
            clearProgress: noop,
            info: noop,
            level: logLevel,
            pause: noop,
            resume: noop,
            showProgress: noop,
            silly: npmLog,
            verbose: npmLog,
            warn: noop,
        },
        runConcurrently: true,
        stdio: (_d = opts.stdio) !== null && _d !== void 0 ? _d : 'pipe',
        unsafePerm: opts.unsafePerm,
    });
    function npmLog(prefix, logid, stdtype, line) {
        switch (stdtype) {
            case 'stdout':
            case 'stderr':
                core_loggers_1.lifecycleLogger.debug({
                    depPath: opts.depPath,
                    line: line.toString(),
                    stage,
                    stdio: stdtype,
                    wd: opts.pkgRoot,
                });
                return;
            case 'Returned: code:': {
                if (opts.stdio === 'inherit') {
                    // Preventing the pnpm reporter from overriding the project's script output
                    return;
                }
                const code = arguments[3];
                core_loggers_1.lifecycleLogger.debug({
                    depPath: opts.depPath,
                    exitCode: code,
                    optional,
                    stage,
                    wd: opts.pkgRoot,
                });
            }
        }
    }
}
exports.default = runLifecycleHook;
function getId(manifest) {
    var _a, _b;
    return `${(_a = manifest.name) !== null && _a !== void 0 ? _a : ''}@${(_b = manifest.version) !== null && _b !== void 0 ? _b : ''}`;
}
//# sourceMappingURL=runLifecycleHook.js.map