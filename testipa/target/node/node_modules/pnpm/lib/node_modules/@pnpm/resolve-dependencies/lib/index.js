"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@pnpm/constants");
const core_loggers_1 = require("@pnpm/core-loggers");
const manifest_utils_1 = require("@pnpm/manifest-utils");
const read_package_json_1 = require("@pnpm/read-package-json");
const types_1 = require("@pnpm/types");
const depPathToRef_1 = __importDefault(require("./depPathToRef"));
const resolveDependencyTree_1 = __importDefault(require("./resolveDependencyTree"));
const resolvePeers_1 = __importDefault(require("./resolvePeers"));
const updateLockfile_1 = __importDefault(require("./updateLockfile"));
const updateProjectManifest_1 = __importDefault(require("./updateProjectManifest"));
const path = require("path");
const R = require("ramda");
async function default_1(importers, opts) {
    var _a, _b, _c;
    const { dependenciesTree, outdatedDependencies, resolvedImporters, resolvedPackagesByDepPath, wantedToBeSkippedPackageIds, } = await resolveDependencyTree_1.default(importers, opts);
    const linkedDependenciesByProjectId = {};
    const projectsToLink = await Promise.all(importers.map(async (project, index) => {
        var _a;
        const resolvedImporter = resolvedImporters[project.id];
        linkedDependenciesByProjectId[project.id] = resolvedImporter.linkedDependencies;
        let updatedManifest = project.manifest;
        let updatedOriginalManifest = project.originalManifest;
        if (project.updatePackageManifest) {
            const manifests = await updateProjectManifest_1.default(importers[index], {
                directDependencies: resolvedImporter.directDependencies,
                preserveWorkspaceProtocol: opts.preserveWorkspaceProtocol,
                saveWorkspaceProtocol: opts.saveWorkspaceProtocol,
            });
            updatedManifest = manifests[0];
            updatedOriginalManifest = manifests[1];
        }
        else {
            core_loggers_1.packageManifestLogger.debug({
                prefix: project.rootDir,
                updated: project.manifest,
            });
        }
        if (updatedManifest) {
            const projectSnapshot = opts.wantedLockfile.importers[project.id];
            opts.wantedLockfile.importers[project.id] = addDirectDependenciesToLockfile(updatedManifest, projectSnapshot, resolvedImporter.linkedDependencies, resolvedImporter.directDependencies, opts.registries);
        }
        const topParents = project.manifest
            ? await getTopParents(R.difference(Object.keys(manifest_utils_1.getAllDependenciesFromManifest(project.manifest)), resolvedImporter.directDependencies
                .filter((dep, index) => project.wantedDependencies[index].isNew === true)
                .map(({ alias }) => alias) || []), project.modulesDir)
            : [];
        project.manifest = (_a = updatedOriginalManifest !== null && updatedOriginalManifest !== void 0 ? updatedOriginalManifest : project.originalManifest) !== null && _a !== void 0 ? _a : project.manifest;
        return {
            binsDir: project.binsDir,
            directNodeIdsByAlias: resolvedImporter.directNodeIdsByAlias,
            id: project.id,
            linkedDependencies: resolvedImporter.linkedDependencies,
            manifest: project.manifest,
            modulesDir: project.modulesDir,
            rootDir: project.rootDir,
            topParents,
        };
    }));
    const { dependenciesGraph, dependenciesByProjectId, } = resolvePeers_1.default({
        dependenciesTree,
        lockfileDir: opts.lockfileDir,
        projects: projectsToLink,
        strictPeerDependencies: opts.strictPeerDependencies,
        virtualStoreDir: opts.virtualStoreDir,
    });
    for (const { id } of projectsToLink) {
        for (const [alias, depPath] of R.toPairs(dependenciesByProjectId[id])) {
            const depNode = dependenciesGraph[depPath];
            if (depNode.isPure)
                continue;
            const projectSnapshot = opts.wantedLockfile.importers[id];
            const ref = depPathToRef_1.default(depPath, {
                alias,
                realName: depNode.name,
                registries: opts.registries,
                resolution: depNode.resolution,
            });
            if ((_a = projectSnapshot.dependencies) === null || _a === void 0 ? void 0 : _a[alias]) {
                projectSnapshot.dependencies[alias] = ref;
            }
            else if ((_b = projectSnapshot.devDependencies) === null || _b === void 0 ? void 0 : _b[alias]) {
                projectSnapshot.devDependencies[alias] = ref;
            }
            else if ((_c = projectSnapshot.optionalDependencies) === null || _c === void 0 ? void 0 : _c[alias]) {
                projectSnapshot.optionalDependencies[alias] = ref;
            }
        }
    }
    const { newLockfile, pendingRequiresBuilds } = updateLockfile_1.default(dependenciesGraph, opts.wantedLockfile, opts.virtualStoreDir, opts.registries); // eslint-disable-line:prefer-const
    // waiting till package requests are finished
    const waitTillAllFetchingsFinish = () => Promise.all(R.values(resolvedPackagesByDepPath).map(({ finishing }) => finishing()));
    return {
        dependenciesByProjectId,
        dependenciesGraph,
        finishLockfileUpdates: finishLockfileUpdates.bind(null, dependenciesGraph, pendingRequiresBuilds, newLockfile),
        outdatedDependencies,
        linkedDependenciesByProjectId,
        newLockfile,
        waitTillAllFetchingsFinish,
        wantedToBeSkippedPackageIds,
    };
}
exports.default = default_1;
function finishLockfileUpdates(dependenciesGraph, pendingRequiresBuilds, newLockfile) {
    return Promise.all(pendingRequiresBuilds.map(async (depPath) => {
        const depNode = dependenciesGraph[depPath];
        if (!depNode.fetchingBundledManifest) {
            // This should never ever happen
            throw new Error(`Cannot create ${constants_1.WANTED_LOCKFILE} because raw manifest (aka package.json) wasn't fetched for "${depPath}"`);
        }
        const filesResponse = await depNode.fetchingFiles();
        // The npm team suggests to always read the package.json for deciding whether the package has lifecycle scripts
        const pkgJson = await depNode.fetchingBundledManifest();
        depNode.requiresBuild = Boolean(pkgJson.scripts != null && (Boolean(pkgJson.scripts.preinstall) ||
            Boolean(pkgJson.scripts.install) ||
            Boolean(pkgJson.scripts.postinstall)) ||
            filesResponse.filesIndex['binding.gyp'] ||
            Object.keys(filesResponse.filesIndex).some((filename) => !!filename.match(/^[.]hooks[\\/]/)) // TODO: optimize this
        );
        // TODO: try to cover with unit test the case when entry is no longer available in lockfile
        // It is an edge that probably happens if the entry is removed during lockfile prune
        if (depNode.requiresBuild && newLockfile.packages[depPath]) {
            newLockfile.packages[depPath].requiresBuild = true;
        }
    }));
}
function addDirectDependenciesToLockfile(newManifest, projectSnapshot, linkedPackages, directDependencies, registries) {
    var _a, _b, _c;
    const newProjectSnapshot = {
        dependencies: {},
        devDependencies: {},
        optionalDependencies: {},
        specifiers: {},
    };
    linkedPackages.forEach((linkedPkg) => {
        newProjectSnapshot.specifiers[linkedPkg.alias] = manifest_utils_1.getSpecFromPackageManifest(newManifest, linkedPkg.alias);
    });
    const directDependenciesByAlias = directDependencies.reduce((acc, directDependency) => {
        acc[directDependency.alias] = directDependency;
        return acc;
    }, {});
    const allDeps = Array.from(new Set(Object.keys(manifest_utils_1.getAllDependenciesFromManifest(newManifest))));
    for (const alias of allDeps) {
        if (directDependenciesByAlias[alias]) {
            const dep = directDependenciesByAlias[alias];
            const ref = depPathToRef_1.default(dep.pkgId, {
                alias: dep.alias,
                realName: dep.name,
                registries,
                resolution: dep.resolution,
            });
            if (dep.dev) {
                newProjectSnapshot.devDependencies[dep.alias] = ref;
            }
            else if (dep.optional) {
                newProjectSnapshot.optionalDependencies[dep.alias] = ref;
            }
            else {
                newProjectSnapshot.dependencies[dep.alias] = ref;
            }
            newProjectSnapshot.specifiers[dep.alias] = manifest_utils_1.getSpecFromPackageManifest(newManifest, dep.alias);
        }
        else if (projectSnapshot.specifiers[alias]) {
            newProjectSnapshot.specifiers[alias] = projectSnapshot.specifiers[alias];
            if ((_a = projectSnapshot.dependencies) === null || _a === void 0 ? void 0 : _a[alias]) {
                newProjectSnapshot.dependencies[alias] = projectSnapshot.dependencies[alias];
            }
            else if ((_b = projectSnapshot.optionalDependencies) === null || _b === void 0 ? void 0 : _b[alias]) {
                newProjectSnapshot.optionalDependencies[alias] = projectSnapshot.optionalDependencies[alias];
            }
            else if ((_c = projectSnapshot.devDependencies) === null || _c === void 0 ? void 0 : _c[alias]) {
                newProjectSnapshot.devDependencies[alias] = projectSnapshot.devDependencies[alias];
            }
        }
    }
    alignDependencyTypes(newManifest, newProjectSnapshot);
    return newProjectSnapshot;
}
function alignDependencyTypes(manifest, projectSnapshot) {
    var _a;
    const depTypesOfAliases = getAliasToDependencyTypeMap(manifest);
    // Aligning the dependency types in pnpm-lock.yaml
    for (const depType of types_1.DEPENDENCIES_FIELDS) {
        if (!projectSnapshot[depType])
            continue;
        for (const alias of Object.keys((_a = projectSnapshot[depType]) !== null && _a !== void 0 ? _a : {})) {
            if (depType === depTypesOfAliases[alias] || !depTypesOfAliases[alias])
                continue;
            projectSnapshot[depTypesOfAliases[alias]][alias] = projectSnapshot[depType][alias];
            delete projectSnapshot[depType][alias];
        }
    }
}
function getAliasToDependencyTypeMap(manifest) {
    var _a;
    const depTypesOfAliases = {};
    for (const depType of types_1.DEPENDENCIES_FIELDS) {
        if (!manifest[depType])
            continue;
        for (const alias of Object.keys((_a = manifest[depType]) !== null && _a !== void 0 ? _a : {})) {
            if (!depTypesOfAliases[alias]) {
                depTypesOfAliases[alias] = depType;
            }
        }
    }
    return depTypesOfAliases;
}
async function getTopParents(pkgNames, modules) {
    const pkgs = await Promise.all(pkgNames.map((pkgName) => path.join(modules, pkgName)).map(read_package_json_1.safeReadPackageFromDir));
    return pkgs
        .filter(Boolean)
        .map(({ name, version }) => ({ name, version }));
}
//# sourceMappingURL=index.js.map