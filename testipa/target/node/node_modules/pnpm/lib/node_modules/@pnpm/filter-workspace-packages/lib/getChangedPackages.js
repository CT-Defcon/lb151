"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __importDefault(require("@pnpm/error"));
const path = require("path");
const execa = require("execa");
const findUp = require("find-up");
const isSubdir = require("is-subdir");
async function changedSince(packageDirs, commit, opts) {
    var _a;
    const repoRoot = path.resolve((_a = await findUp('.git', { cwd: opts.workspaceDir, type: 'directory' })) !== null && _a !== void 0 ? _a : opts.workspaceDir, '..');
    let changedDirs = Array.from(await getChangedDirsSinceCommit(commit, opts.workspaceDir)).map(changedDir => path.join(repoRoot, changedDir));
    const changedPkgs = [];
    for (const packageDir of packageDirs.sort((pkgDir1, pkgDir2) => pkgDir2.length - pkgDir1.length)) {
        if (changedDirs.some(changedDir => isSubdir(packageDir, changedDir))) {
            changedDirs = changedDirs.filter((changedDir) => !isSubdir(packageDir, changedDir));
            changedPkgs.push(packageDir);
        }
    }
    return changedPkgs;
}
exports.default = changedSince;
async function getChangedDirsSinceCommit(commit, workingDir) {
    let diff;
    try {
        diff = (await execa('git', [
            'diff',
            '--name-only',
            commit,
            '--',
            workingDir,
        ], { cwd: workingDir })).stdout;
    }
    catch (err) {
        throw new error_1.default('FILTER_CHANGED', `Filtering by changed packages failed. ${err.stderr}`);
    }
    const changedDirs = new Set();
    if (!diff) {
        return changedDirs;
    }
    const changedFiles = diff.split('\n');
    for (const changedFile of changedFiles) {
        changedDirs.add(path.dirname(changedFile));
    }
    return changedDirs;
}
//# sourceMappingURL=getChangedPackages.js.map