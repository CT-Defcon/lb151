"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@pnpm/client");
const pick_registry_for_package_1 = __importDefault(require("@pnpm/pick-registry-for-package"));
const sort_packages_1 = __importDefault(require("@pnpm/sort-packages"));
const store_path_1 = __importDefault(require("@pnpm/store-path"));
const publish_1 = require("./publish");
const pFilter = require("p-filter");
async function default_1(opts) {
    var _a;
    const pkgs = Object.values(opts.selectedProjectsGraph).map((wsPkg) => wsPkg.package);
    const storeDir = await store_path_1.default(opts.workspaceDir, opts.storeDir);
    const resolve = client_1.createResolver(Object.assign(opts, {
        authConfig: opts.rawConfig,
        storeDir,
    }));
    const pkgsToPublish = await pFilter(pkgs, async (pkg) => {
        var _a;
        if (!pkg.manifest.name || !pkg.manifest.version || pkg.manifest.private)
            return false;
        return !(await isAlreadyPublished({
            dir: pkg.dir,
            lockfileDir: (_a = opts.lockfileDir) !== null && _a !== void 0 ? _a : pkg.dir,
            registries: opts.registries,
            resolve,
        }, pkg.manifest.name, pkg.manifest.version));
    });
    const publishedPkgDirs = new Set(pkgsToPublish.map(({ dir }) => dir));
    const appendedArgs = [];
    if (opts.cliOptions['access']) {
        appendedArgs.push(`--access=${opts.cliOptions['access']}`);
    }
    if (opts.dryRun) {
        appendedArgs.push('--dry-run');
    }
    const chunks = sort_packages_1.default(opts.selectedProjectsGraph);
    const tag = (_a = opts.tag) !== null && _a !== void 0 ? _a : 'latest';
    for (const chunk of chunks) {
        for (const pkgDir of chunk) {
            if (!publishedPkgDirs.has(pkgDir))
                continue;
            const pkg = opts.selectedProjectsGraph[pkgDir].package;
            await publish_1.handler({
                ...opts,
                argv: {
                    original: [
                        'publish',
                        pkg.dir,
                        '--tag',
                        tag,
                        '--registry',
                        pick_registry_for_package_1.default(opts.registries, pkg.manifest.name),
                        ...appendedArgs,
                    ],
                },
                gitChecks: false,
                recursive: false,
            }, [pkg.dir]);
        }
    }
}
exports.default = default_1;
async function isAlreadyPublished(opts, pkgName, pkgVersion) {
    try {
        await opts.resolve({ alias: pkgName, pref: pkgVersion }, {
            lockfileDir: opts.lockfileDir,
            preferredVersions: {},
            projectDir: opts.dir,
            registry: pick_registry_for_package_1.default(opts.registries, pkgName),
        });
        return true;
    }
    catch (err) {
        return false;
    }
}
//# sourceMappingURL=recursivePublish.js.map