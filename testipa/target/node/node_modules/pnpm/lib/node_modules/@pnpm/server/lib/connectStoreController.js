"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fetch_1 = __importDefault(require("@pnpm/fetch"));
const pLimit = require("p-limit");
const pShare = require("promise-share");
const uuid = require("uuid");
function default_1(initOpts) {
    var _a;
    const remotePrefix = initOpts.remotePrefix;
    const limitedFetch = limitFetch.bind(null, pLimit((_a = initOpts.concurrency) !== null && _a !== void 0 ? _a : 100));
    return new Promise((resolve, reject) => {
        resolve({
            close: async () => { },
            fetchPackage: fetchPackage.bind(null, remotePrefix, limitedFetch),
            importPackage: (to, opts) => {
                return limitedFetch(`${remotePrefix}/importPackage`, {
                    opts,
                    to,
                });
            },
            prune: async () => {
                await limitedFetch(`${remotePrefix}/prune`, {});
            },
            requestPackage: requestPackage.bind(null, remotePrefix, limitedFetch),
            stop: async () => {
                await limitedFetch(`${remotePrefix}/stop`, {});
            },
            upload: async (builtPkgLocation, opts) => {
                await limitedFetch(`${remotePrefix}/upload`, {
                    builtPkgLocation,
                    opts,
                });
            },
        });
    });
}
exports.default = default_1;
function limitFetch(limit, url, body) {
    return limit(async () => {
        // TODO: the http://unix: should be also supported by the fetcher
        // but it fails with node-fetch-unix as of v2.3.0
        if (url.startsWith('http://unix:')) {
            url = url.replace('http://unix:', 'unix:');
        }
        const response = await fetch_1.default(url, {
            body: JSON.stringify(body),
            headers: { 'Content-Type': 'application/json' },
            method: 'POST',
            retry: {
                retries: 100,
            },
        });
        if (!response.ok) {
            throw await response.json();
        }
        const json = await response.json();
        if (json.error) {
            throw json.error;
        }
        return json;
    });
}
function requestPackage(remotePrefix, limitedFetch, // eslint-disable-line
wantedDependency, options) {
    const msgId = uuid.v4();
    return limitedFetch(`${remotePrefix}/requestPackage`, {
        msgId,
        options,
        wantedDependency,
    })
        .then((packageResponseBody) => {
        const fetchingBundledManifest = !packageResponseBody['fetchingBundledManifestInProgress'] // eslint-disable-line
            ? undefined
            : limitedFetch(`${remotePrefix}/rawManifestResponse`, {
                msgId,
            });
        delete packageResponseBody['fetchingBundledManifestInProgress']; // eslint-disable-line
        if (options.skipFetch) {
            return {
                body: packageResponseBody,
                bundledManifest: fetchingBundledManifest && pShare(fetchingBundledManifest),
            };
        }
        const fetchingFiles = limitedFetch(`${remotePrefix}/packageFilesResponse`, {
            msgId,
        });
        return {
            body: packageResponseBody,
            bundledManifest: fetchingBundledManifest && pShare(fetchingBundledManifest),
            files: pShare(fetchingFiles),
            finishing: pShare(Promise.all([fetchingBundledManifest, fetchingFiles]).then(() => undefined)),
        };
    });
}
function fetchPackage(remotePrefix, limitedFetch, // eslint-disable-line
options) {
    const msgId = uuid.v4();
    return limitedFetch(`${remotePrefix}/fetchPackage`, {
        msgId,
        options,
    })
        .then((fetchResponseBody) => {
        const fetchingBundledManifest = options.fetchRawManifest
            ? limitedFetch(`${remotePrefix}/rawManifestResponse`, { msgId })
            : undefined;
        const fetchingFiles = limitedFetch(`${remotePrefix}/packageFilesResponse`, {
            msgId,
        });
        return {
            bundledManifest: fetchingBundledManifest && pShare(fetchingBundledManifest),
            files: pShare(fetchingFiles),
            filesIndexFile: fetchResponseBody.filesIndexFile,
            finishing: pShare(Promise.all([fetchingBundledManifest, fetchingFiles]).then(() => undefined)),
            inStoreLocation: fetchResponseBody.inStoreLocation,
        };
    });
}
//# sourceMappingURL=connectStoreController.js.map