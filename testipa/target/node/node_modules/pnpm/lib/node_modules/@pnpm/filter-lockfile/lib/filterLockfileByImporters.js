"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@pnpm/constants");
const lockfile_walker_1 = __importDefault(require("@pnpm/lockfile-walker"));
const logger_1 = __importDefault(require("@pnpm/logger"));
const filterImporter_1 = __importDefault(require("./filterImporter"));
const LockfileMissingDependencyError_1 = __importDefault(require("./LockfileMissingDependencyError"));
const logger = logger_1.default('lockfile');
function filterByImporters(lockfile, importerIds, opts) {
    const packages = {};
    if (lockfile.packages) {
        pkgAllDeps(lockfile_walker_1.default(lockfile, importerIds, { include: opts.include, skipped: opts.skipped }).step, packages, {
            failOnMissingDependencies: opts.failOnMissingDependencies,
        });
    }
    const importers = importerIds.reduce((acc, importerId) => {
        acc[importerId] = filterImporter_1.default(lockfile.importers[importerId], opts.include);
        return acc;
    }, { ...lockfile.importers });
    return {
        importers,
        lockfileVersion: lockfile.lockfileVersion,
        packages,
    };
}
exports.default = filterByImporters;
function pkgAllDeps(step, pickedPackages, opts) {
    for (const { pkgSnapshot, depPath, next } of step.dependencies) {
        pickedPackages[depPath] = pkgSnapshot;
        pkgAllDeps(next(), pickedPackages, opts);
    }
    for (const depPath of step.missing) {
        if (opts.failOnMissingDependencies) {
            throw new LockfileMissingDependencyError_1.default(depPath);
        }
        logger.debug(`No entry for "${depPath}" in ${constants_1.WANTED_LOCKFILE}`);
    }
}
//# sourceMappingURL=filterLockfileByImporters.js.map