"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@pnpm/constants");
const lockfile_utils_1 = require("@pnpm/lockfile-utils");
const logger_1 = __importDefault(require("@pnpm/logger"));
const package_is_installable_1 = __importDefault(require("@pnpm/package-is-installable"));
const dp = __importStar(require("dependency-path"));
const filterImporter_1 = __importDefault(require("./filterImporter"));
const LockfileMissingDependencyError_1 = __importDefault(require("./LockfileMissingDependencyError"));
const R = require("ramda");
const logger = logger_1.default('lockfile');
function filterByImportersAndEngine(lockfile, importerIds, opts) {
    var _a;
    const importerDeps = importerIds
        .map((importerId) => lockfile.importers[importerId])
        .map((importer) => ({
        ...(opts.include.dependencies ? importer.dependencies : {}),
        ...(opts.include.devDependencies ? importer.devDependencies : {}),
        ...(opts.include.optionalDependencies ? importer.optionalDependencies : {}),
    }))
        .map(Object.entries);
    const directDepPaths = R.unnest(importerDeps)
        .map(([pkgName, ref]) => dp.refToRelative(ref, pkgName))
        .filter((nodeId) => nodeId !== null);
    const packages = (_a = (lockfile.packages &&
        pickPkgsWithAllDeps(lockfile.packages, directDepPaths, {
            currentEngine: opts.currentEngine,
            engineStrict: opts.engineStrict,
            failOnMissingDependencies: opts.failOnMissingDependencies,
            include: opts.include,
            includeIncompatiblePackages: opts.includeIncompatiblePackages === true,
            lockfileDir: opts.lockfileDir,
            skipped: opts.skipped,
        }))) !== null && _a !== void 0 ? _a : {};
    const importers = importerIds.reduce((acc, importerId) => {
        var _a;
        acc[importerId] = filterImporter_1.default(lockfile.importers[importerId], opts.include);
        if (acc[importerId].optionalDependencies) {
            for (const depName of Object.keys((_a = acc[importerId].optionalDependencies) !== null && _a !== void 0 ? _a : {})) {
                const depPath = dp.refToRelative(acc[importerId].optionalDependencies[depName], depName);
                if (depPath && !packages[depPath]) {
                    delete acc[importerId].optionalDependencies[depName];
                }
            }
        }
        return acc;
    }, { ...lockfile.importers });
    return {
        importers,
        lockfileVersion: lockfile.lockfileVersion,
        packages,
    };
}
exports.default = filterByImportersAndEngine;
function pickPkgsWithAllDeps(pkgSnapshots, depPaths, opts) {
    const pickedPackages = {};
    pkgAllDeps({ pkgSnapshots, pickedPackages }, depPaths, true, opts);
    return pickedPackages;
}
function pkgAllDeps(ctx, depPaths, parentIsInstallable, opts) {
    var _a;
    for (const depPath of depPaths) {
        if (ctx.pickedPackages[depPath])
            continue;
        const pkgSnapshot = ctx.pkgSnapshots[depPath];
        if (!pkgSnapshot && !depPath.startsWith('link:')) {
            if (opts.failOnMissingDependencies) {
                throw new LockfileMissingDependencyError_1.default(depPath);
            }
            logger.debug(`No entry for "${depPath}" in ${constants_1.WANTED_LOCKFILE}`);
            continue;
        }
        let installable;
        if (!parentIsInstallable) {
            installable = false;
            if (!ctx.pickedPackages[depPath] && pkgSnapshot.optional === true) {
                opts.skipped.add(depPath);
            }
        }
        else {
            const pkg = {
                ...lockfile_utils_1.nameVerFromPkgSnapshot(depPath, pkgSnapshot),
                cpu: pkgSnapshot.cpu,
                engines: pkgSnapshot.engines,
                os: pkgSnapshot.os,
            };
            // TODO: depPath is not the package ID. Should be fixed
            installable = opts.includeIncompatiblePackages || package_is_installable_1.default((_a = pkgSnapshot.id) !== null && _a !== void 0 ? _a : depPath, pkg, {
                engineStrict: opts.engineStrict,
                lockfileDir: opts.lockfileDir,
                nodeVersion: opts.currentEngine.nodeVersion,
                optional: pkgSnapshot.optional === true,
                pnpmVersion: opts.currentEngine.pnpmVersion,
            }) !== false;
            if (!installable) {
                if (!ctx.pickedPackages[depPath] && pkgSnapshot.optional === true) {
                    opts.skipped.add(depPath);
                }
            }
            else {
                opts.skipped.delete(depPath);
            }
        }
        ctx.pickedPackages[depPath] = pkgSnapshot;
        const nextRelDepPaths = Object.entries({
            ...pkgSnapshot.dependencies,
            ...(opts.include.optionalDependencies ? pkgSnapshot.optionalDependencies : {}),
        })
            .map(([pkgName, ref]) => {
            var _a;
            if ((_a = pkgSnapshot.peerDependencies) === null || _a === void 0 ? void 0 : _a[pkgName])
                return null;
            return dp.refToRelative(ref, pkgName);
        })
            .filter((nodeId) => nodeId !== null);
        pkgAllDeps(ctx, nextRelDepPaths, installable, opts);
    }
}
//# sourceMappingURL=filterLockfileByImportersAndEngine.js.map