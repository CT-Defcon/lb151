"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lockfileWalkerGroupImporterSteps = void 0;
const dp = require("dependency-path");
const R = require("ramda");
function lockfileWalkerGroupImporterSteps(lockfile, importerIds, opts) {
    const walked = new Set((opts === null || opts === void 0 ? void 0 : opts.skipped) ? Array.from(opts === null || opts === void 0 ? void 0 : opts.skipped) : []);
    return importerIds.map((importerId) => {
        var _a, _b, _c, _d;
        const projectSnapshot = lockfile.importers[importerId];
        const entryNodes = R.toPairs({
            ...(((_a = opts === null || opts === void 0 ? void 0 : opts.include) === null || _a === void 0 ? void 0 : _a.devDependencies) === false ? {} : projectSnapshot.devDependencies),
            ...(((_b = opts === null || opts === void 0 ? void 0 : opts.include) === null || _b === void 0 ? void 0 : _b.dependencies) === false ? {} : projectSnapshot.dependencies),
            ...(((_c = opts === null || opts === void 0 ? void 0 : opts.include) === null || _c === void 0 ? void 0 : _c.optionalDependencies) === false ? {} : projectSnapshot.optionalDependencies),
        })
            .map(([pkgName, reference]) => dp.refToRelative(reference, pkgName))
            .filter((nodeId) => nodeId !== null);
        return {
            importerId,
            step: step({
                includeOptionalDependencies: ((_d = opts === null || opts === void 0 ? void 0 : opts.include) === null || _d === void 0 ? void 0 : _d.optionalDependencies) !== false,
                lockfile,
                walked,
            }, entryNodes),
        };
    });
}
exports.lockfileWalkerGroupImporterSteps = lockfileWalkerGroupImporterSteps;
function lockfileWalker(lockfile, importerIds, opts) {
    var _a;
    const walked = new Set((opts === null || opts === void 0 ? void 0 : opts.skipped) ? Array.from(opts === null || opts === void 0 ? void 0 : opts.skipped) : []);
    const entryNodes = [];
    const directDeps = [];
    importerIds.forEach((importerId) => {
        var _a, _b, _c;
        const projectSnapshot = lockfile.importers[importerId];
        R.toPairs({
            ...(((_a = opts === null || opts === void 0 ? void 0 : opts.include) === null || _a === void 0 ? void 0 : _a.devDependencies) === false ? {} : projectSnapshot.devDependencies),
            ...(((_b = opts === null || opts === void 0 ? void 0 : opts.include) === null || _b === void 0 ? void 0 : _b.dependencies) === false ? {} : projectSnapshot.dependencies),
            ...(((_c = opts === null || opts === void 0 ? void 0 : opts.include) === null || _c === void 0 ? void 0 : _c.optionalDependencies) === false ? {} : projectSnapshot.optionalDependencies),
        })
            .forEach(([pkgName, reference]) => {
            const depPath = dp.refToRelative(reference, pkgName);
            if (depPath === null)
                return;
            entryNodes.push(depPath);
            directDeps.push({ alias: pkgName, depPath });
        });
    });
    return {
        directDeps,
        step: step({
            includeOptionalDependencies: ((_a = opts === null || opts === void 0 ? void 0 : opts.include) === null || _a === void 0 ? void 0 : _a.optionalDependencies) !== false,
            lockfile,
            walked,
        }, entryNodes),
    };
}
exports.default = lockfileWalker;
function step(ctx, nextDepPaths) {
    var _a;
    const result = {
        dependencies: [],
        links: [],
        missing: [],
    };
    for (let depPath of nextDepPaths) {
        if (ctx.walked.has(depPath))
            continue;
        ctx.walked.add(depPath);
        const pkgSnapshot = (_a = ctx.lockfile.packages) === null || _a === void 0 ? void 0 : _a[depPath];
        if (!pkgSnapshot) {
            if (depPath.startsWith('link:')) {
                result.links.push(depPath);
                continue;
            }
            result.missing.push(depPath);
            continue;
        }
        result.dependencies.push({
            depPath,
            next: () => step(ctx, next({ includeOptionalDependencies: ctx.includeOptionalDependencies }, pkgSnapshot)),
            pkgSnapshot,
        });
    }
    return result;
}
function next(opts, nextPkg) {
    return R.toPairs({
        ...nextPkg.dependencies,
        ...(opts.includeOptionalDependencies ? nextPkg.optionalDependencies : {}),
    })
        .map(([pkgName, reference]) => dp.refToRelative(reference, pkgName))
        .filter((nodeId) => nodeId !== null);
}
//# sourceMappingURL=index.js.map