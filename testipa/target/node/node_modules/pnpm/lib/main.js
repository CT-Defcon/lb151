"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Map SIGINT & SIGTERM to process exit
// so that lockfiles are removed automatically
const loud_rejection_1 = __importDefault(require("loud-rejection"));
const cli_meta_1 = __importDefault(require("@pnpm/cli-meta"));
const cli_utils_1 = require("@pnpm/cli-utils");
const core_loggers_1 = require("@pnpm/core-loggers");
const filter_workspace_packages_1 = require("@pnpm/filter-workspace-packages");
const find_workspace_packages_1 = __importDefault(require("@pnpm/find-workspace-packages"));
const logger_1 = __importDefault(require("@pnpm/logger"));
const checkForUpdates_1 = __importDefault(require("./checkForUpdates"));
const cmd_1 = __importStar(require("./cmd"));
const formatError_1 = require("./formatError");
require("./logging/fileLogger");
const parseCliArgs_1 = __importDefault(require("./parseCliArgs"));
const reporter_1 = __importDefault(require("./reporter"));
const chalk = require("chalk");
process
    .once('SIGINT', () => process.exit(0))
    .once('SIGTERM', () => process.exit(0));
// Patch the global fs module here at the app level
const fs = require("fs");
const gfs = require("graceful-fs");
gfs.gracefulify(fs);
loud_rejection_1.default();
const isCI = require("is-ci");
const path = require("path");
const R = require("ramda");
const stripAnsi = require("strip-ansi");
const which = require("which");
const DEPRECATED_OPTIONS = new Set([
    'independent-leaves',
    'lock',
    'resolution-strategy',
]);
async function run(inputArgv) {
    var _a;
    const { argv, params: cliParams, options: cliOptions, cmd, unknownOptions, workspaceDir, } = await parseCliArgs_1.default(inputArgv);
    if (cmd !== null && !cmd_1.default[cmd]) {
        console.error(`${chalk.bgRed.black('\u2009ERROR\u2009')} ${chalk.red(`Unknown command '${cmd}'`)}`);
        console.log('For help, run: pnpm help');
        process.exit(1);
    }
    if (unknownOptions.size > 0) {
        const unknownOptionsArray = Array.from(unknownOptions.keys());
        if (unknownOptionsArray.every((option) => DEPRECATED_OPTIONS.has(option))) {
            let deprecationMsg = `${chalk.bgYellow.black('\u2009WARN\u2009')}`;
            if (unknownOptionsArray.length === 1) {
                deprecationMsg += ` ${chalk.yellow(`Deprecated option: '${unknownOptionsArray[0]}'`)}`;
            }
            else {
                deprecationMsg += ` ${chalk.yellow(`Deprecated options: ${unknownOptionsArray.map(unknownOption => `'${unknownOption}'`).join(', ')}`)}`;
            }
            console.log(deprecationMsg);
        }
        else {
            console.error(formatError_1.formatUnknownOptionsError(unknownOptions));
            console.log(`For help, run: pnpm help${cmd ? ` ${cmd}` : ''}`);
            process.exit(1);
        }
    }
    process.env['npm_config_argv'] = JSON.stringify(argv);
    let config;
    try {
        // When we just want to print the location of the global bin directory,
        // we don't need the write permission to it. Related issue: #2700
        const globalDirShouldAllowWrite = cmd !== 'root';
        config = await cli_utils_1.getConfig(cliOptions, {
            excludeReporter: false,
            globalDirShouldAllowWrite,
            rcOptionsTypes: cmd_1.getRCOptionsTypes(cmd),
            workspaceDir,
        });
        config.forceSharedLockfile = typeof config.workspaceDir === 'string' && config.sharedWorkspaceLockfile === true;
        config.argv = argv;
    }
    catch (err) {
        // Reporting is not initialized at this point, so just printing the error
        console.error(`${chalk.bgRed.black('\u2009ERROR\u2009')} ${chalk.red(err.message)}`);
        if (err['hint']) {
            console.log(err['hint']);
        }
        else {
            console.log(`For help, run: pnpm help${cmd ? ` ${cmd}` : ''}`);
        }
        process.exit(1);
    }
    let write = process.stdout.write.bind(process.stdout);
    // chalk reads the FORCE_COLOR env variable
    if (config.color === 'always') {
        process.env['FORCE_COLOR'] = '1';
    }
    else if (config.color === 'never') {
        process.env['FORCE_COLOR'] = '0';
        // In some cases, it is already late to set the FORCE_COLOR env variable.
        // Some text might be already generated.
        //
        // A better solution might be to dynamically load all the code after the settings are read
        // and the env variable set.
        write = (text) => process.stdout.write(stripAnsi(text));
    }
    const selfUpdate = config.global && (cmd === 'add' || cmd === 'update') && cliParams.includes(cli_meta_1.default.name);
    // Don't check for updates
    //   1. on CI environments
    //   2. when in the middle of an actual update
    if (!isCI && !selfUpdate) {
        checkForUpdates_1.default();
    }
    const reporterType = (() => {
        if (config.loglevel === 'silent')
            return 'silent';
        if (config.reporter)
            return config.reporter;
        if (isCI || !process.stdout.isTTY)
            return 'append-only';
        return 'default';
    })();
    reporter_1.default(reporterType, {
        cmd,
        config,
    });
    global['reporterInitialized'] = reporterType;
    if (selfUpdate) {
        await cmd_1.default.server(config, ['stop']); // eslint-disable-line @typescript-eslint/no-explicit-any
        try {
            config.bin = path.dirname(which.sync('pnpm'));
        }
        catch (err) {
            // if pnpm not found, then ignore
        }
    }
    if (cmd === 'install' &&
        typeof workspaceDir === 'string') {
        cliOptions['recursive'] = true;
        config.recursive = true;
        if (!config.recursiveInstall && !config.filter) {
            config.filter = ['{.}...'];
        }
    }
    if (cliOptions['recursive']) {
        const wsDir = workspaceDir !== null && workspaceDir !== void 0 ? workspaceDir : process.cwd();
        const allProjects = await find_workspace_packages_1.default(wsDir, {
            engineStrict: config.engineStrict,
            patterns: cliOptions['workspace-packages'],
        });
        if (!allProjects.length) {
            if (!config['parseable']) {
                console.log(`No projects found in "${wsDir}"`);
            }
            process.exit(0);
        }
        const filterResults = await filter_workspace_packages_1.filterPackages(allProjects, (_a = config.filter) !== null && _a !== void 0 ? _a : [], {
            linkWorkspacePackages: !!config.linkWorkspacePackages,
            prefix: process.cwd(),
            workspaceDir: wsDir,
        });
        config.selectedProjectsGraph = filterResults.selectedProjectsGraph;
        if (R.isEmpty(config.selectedProjectsGraph)) {
            if (!config['parseable']) {
                console.log(`No projects matched the filters in "${wsDir}"`);
            }
            process.exit(0);
        }
        if (filterResults.unmatchedFilters.length !== 0 && !config['parseable']) {
            console.log(`No projects matched the filters "${filterResults.unmatchedFilters.join(', ')}" in "${wsDir}"`);
        }
        config.allProjects = allProjects;
        config.workspaceDir = wsDir;
    }
    // NOTE: we defer the next stage, otherwise reporter might not catch all the logs
    const [output, exitCode] = await new Promise((resolve, reject) => {
        setTimeout(async () => {
            if (config.force === true) {
                logger_1.default.warn({
                    message: 'using --force I sure hope you know what you are doing',
                    prefix: config.dir,
                });
            }
            core_loggers_1.scopeLogger.debug({
                ...(!cliOptions['recursive']
                    ? { selected: 1 }
                    : {
                        selected: Object.keys(config.selectedProjectsGraph).length,
                        total: config.allProjects.length,
                    }),
                ...(workspaceDir ? { workspacePrefix: workspaceDir } : {}),
            });
            try {
                let result = cmd_1.default[cmd !== null && cmd !== void 0 ? cmd : 'help'](
                // TypeScript doesn't currently infer that the type of config
                // is `Omit<typeof config, 'reporter'>` after the `delete config.reporter` statement
                config, cliParams);
                if (result instanceof Promise) {
                    result = await result;
                }
                if (!result) {
                    resolve([null, 0]);
                    return;
                }
                if (typeof result === 'string') {
                    resolve([result, 0]);
                    return;
                }
                resolve([result['output'], result['exitCode']]);
            }
            catch (err) {
                reject(err);
            }
        }, 0);
    });
    if (output) {
        write(output);
    }
    if (!cmd) {
        process.exit(1);
    }
    if (exitCode) {
        process.exit(exitCode);
    }
}
exports.default = run;
